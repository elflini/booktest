<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 분석 | 건강보험 청구자료 분석 지침 - 사회약학</title>
  <meta name="description" content="사회약학 연구지침" />
  <meta name="generator" content="bookdown 0.24 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 분석 | 건강보험 청구자료 분석 지침 - 사회약학" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="사회약학 연구지침" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 분석 | 건강보험 청구자료 분석 지침 - 사회약학" />
  
  <meta name="twitter:description" content="사회약학 연구지침" />
  

<meta name="author" content="Jin Hyun Nam" />


<meta name="date" content="2021-12-24" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="chapter2.html"/>
<link rel="next" href="chapter4.html"/>
<script src="libs/header-attrs-2.11/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>




<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">사회약학 연구지침</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>머리말</a></li>
<li class="chapter" data-level="1" data-path="chapter1.html"><a href="chapter1.html"><i class="fa fa-check"></i><b>1</b> IRB 신청</a>
<ul>
<li class="chapter" data-level="1.1" data-path="chapter1.html"><a href="chapter1.html#irb-신청"><i class="fa fa-check"></i><b>1.1</b> IRB 신청</a></li>
<li class="chapter" data-level="1.2" data-path="chapter1.html"><a href="chapter1.html#irb-신청-확인"><i class="fa fa-check"></i><b>1.2</b> IRB 신청 확인</a></li>
<li class="chapter" data-level="1.3" data-path="chapter1.html"><a href="chapter1.html#보고서"><i class="fa fa-check"></i><b>1.3</b> 보고서</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="chapter2.html"><a href="chapter2.html"><i class="fa fa-check"></i><b>2</b> 건강보험 청구자료</a>
<ul>
<li class="chapter" data-level="2.1" data-path="chapter2.html"><a href="chapter2.html#국민건강보험공단-자료원"><i class="fa fa-check"></i><b>2.1</b> 국민건강보험공단 자료원</a></li>
<li class="chapter" data-level="2.2" data-path="chapter2.html"><a href="chapter2.html#건강보험심사평가원hira-자료원"><i class="fa fa-check"></i><b>2.2</b> 건강보험심사평가원(HIRA) 자료원</a></li>
<li class="chapter" data-level="2.3" data-path="chapter2.html"><a href="chapter2.html#공단-및-심평원-자료-비교"><i class="fa fa-check"></i><b>2.3</b> 공단 및 심평원 자료 비교</a></li>
<li class="chapter" data-level="2.4" data-path="chapter2.html"><a href="chapter2.html#공단과-심평원-원격-setup"><i class="fa fa-check"></i><b>2.4</b> 공단과 심평원 원격 Setup</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="chapter3.html"><a href="chapter3.html"><i class="fa fa-check"></i><b>3</b> 분석</a>
<ul>
<li class="chapter" data-level="3.1" data-path="chapter3.html"><a href="chapter3.html#연구디자인-및-환자-선정"><i class="fa fa-check"></i><b>3.1</b> 연구디자인 및 환자 선정</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="chapter3.html"><a href="chapter3.html#환자-선정과정-및-기초특성-추출"><i class="fa fa-check"></i><b>3.1.1</b> 환자 선정과정 및 기초특성 추출</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="chapter3.html"><a href="chapter3.html#비용-및-의료자원-이용"><i class="fa fa-check"></i><b>3.2</b> 비용 및 의료자원 이용</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="chapter3.html"><a href="chapter3.html#비용-산출"><i class="fa fa-check"></i><b>3.2.1</b> 비용 산출</a></li>
<li class="chapter" data-level="3.2.2" data-path="chapter3.html"><a href="chapter3.html#의료자원-이용-연구"><i class="fa fa-check"></i><b>3.2.2</b> 의료자원 이용 연구</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="chapter4.html"><a href="chapter4.html"><i class="fa fa-check"></i><b>4</b> 부록</a>
<ul>
<li class="chapter" data-level="4.1" data-path="chapter4.html"><a href="chapter4.html#sas-갱신-매뉴얼"><i class="fa fa-check"></i><b>4.1</b> SAS 갱신 매뉴얼</a></li>
<li class="chapter" data-level="4.2" data-path="chapter4.html"><a href="chapter4.html#공단-및-심평원-자료신청-행정-절차"><i class="fa fa-check"></i><b>4.2</b> 공단 및 심평원 자료신청 행정 절차</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="chapter4.html"><a href="chapter4.html#표본-코호트-2.0-db"><i class="fa fa-check"></i><b>4.2.1</b> 표본 코호트 2.0 DB</a></li>
<li class="chapter" data-level="4.2.2" data-path="chapter4.html"><a href="chapter4.html#심평원-db"><i class="fa fa-check"></i><b>4.2.2</b> ** 심평원 DB**</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="chapter4.html"><a href="chapter4.html#약가파일"><i class="fa fa-check"></i><b>4.3</b> 약가파일</a>
<ul>
<li class="chapter" data-level="" data-path="chapter4.html"><a href="chapter4.html#약가파일이란"><i class="fa fa-check"></i>약가파일이란?</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">건강보험 청구자료 분석 지침 - 사회약학</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="chapter3" class="section level1" number="3">
<h1><span class="header-section-number">Chapter 3</span> 분석</h1>
<ul>
<li><p>분석에 앞서, 연구 전반에 걸쳐, <span style="color:red">유사 선행연구의 고찰은 필수</span>적임 (연구디자인 인용뿐 아니라, 논문 제출 시 목표로 하는 저널 선정에 도움).</p></li>
<li><p>연구디자인 관련 용이한 이해를 위하여 일반적으로 활용되는 용어는 다음과 같음</p></li>
</ul>
<p><img src="fig3/fig3_1.jpg" /></p>
<pre><code>[그림 3-1] 연구디자인 예시  </code></pre>
<table>
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Study period</td>
<td align="left">연구기간으로 가용자료원의 기간으로 정의될 수 있음</td>
</tr>
<tr class="even">
<td>Index period</td>
<td align="left">연구기간 중 환자를 선정하는데 활용된 기간</td>
</tr>
<tr class="odd">
<td>Index date</td>
<td align="left">Index period 중 선정기준에 부합하여 선정되는 날을 일반적으로 index date로 정의하며, 이 이후부터 추적관찰이 시작됨</td>
</tr>
<tr class="even">
<td>Pre-index period</td>
<td align="left">Index date 이전의 기간을 의미하며, pre-index period의 기간은 연구디자인에 따라 상이하지만 보통 1년 적용 <br> - 해당 기간 동안 일반적으로 baseline characteristics를 추출함</td>
</tr>
<tr class="odd">
<td>Post-index period 혹은 follow-up period</td>
<td align="left">index date 이후의 기간으로, 환자의 추적관찰기간을 의미함</td>
</tr>
</tbody>
</table>
<div id="연구디자인-및-환자-선정" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> 연구디자인 및 환자 선정</h2>
<ul>
<li>수록 내용
<ul>
<li>ICD-10 코드 혹은 의약품 사용내역을 바탕, 시술 내역 등으로 환자 선정<br />
</li>
<li>환자 선정 과정 후 pre-index 기간을 설정하고 기초특성을 정의</li>
</ul></li>
</ul>
<div id="분석-전-고려사항" class="section level4 unnumbered">
<h4>분석 전 고려사항</h4>
<ul>
<li>환자 선정 기준
<ul>
<li>대상질환에 따라 환자를 정의하는 방법을 잘 고찰해야함<br />
</li>
<li>아래 예시에 따라, 환자를 ICD-10코드로 정의하거나, 특정 상태에 적용되는 시술 내역 혹은 치료제 처방 내역을 적용할 수 있음<br />
</li>
<li>pubmed 혹은 구글 등에서 “대상 질환 &amp; claims database”로 선행연구 고찰하여 선정기준을 참고할 수 있음</li>
</ul></li>
<li>연구 디자인 정의
<ul>
<li>자료원에 따라 자료원 기간이 상이하므로 이를 고려한 자료원 선정 및 index_period, pre-index period 및 follow-up period를 정의가 중요함.<br />
</li>
<li>study period 내에서 <span style="color:red">최소 pre-index 기간+ index period+ 최소 follow-up 기간</span>이 될 수 있게 고려해야 함. 간혹, index period가 특정 날짜를 포함해야 할 수 있으므로 <span style="color:red">자료원 신청 전에 확인필수</span> (예: 2014년 1월 1일자로 급여된 약이 포함된다면, index period가 2013년 12월 31일자로 종료되면 안됨)<br />
</li>
<li>디자인을 정의하는 과정에서 <span style="color:red">급여기준 및 정책 변동과 같은 내용도 포괄적으로 고려</span>해야함 (예: 비용연구 혹은 사용패턴의 경우 결과에 영향을 주게 됨, 혹은 이러한 요인이 논문 주제가 될 수도 있음)</li>
</ul></li>
<li>기초 특성 정의
<ul>
<li>연령, 성별, Charlson comorbidity index 등이 일반적으로 포함됨<br />
</li>
<li>대상 질환 및 특성에 따른 복용약물 및 동반질병도 구체적으로 고려해야함</li>
</ul></li>
<li>상기 내용 정의 후, 분석 전 <span style="color:red">국내 임상전문가의 자문을 받는 것이 좋음</span>
<ul>
<li>국내 현실에 맞지 않는 조건일 수도 있거나, 임상적 혹은 행정적으로 명확히 환자를 구분할 수 있는 구분방법이 있을 수 있음 (예: 암에서 v코드). 또한, 질병의 특성에 따라 질병코드만으로는 정의할 경우 selection bias 위험이 높은 경우도 있어, 추가 조건을 고려해야 할 수도 있음 (예: 질병코드 포함 명세건 이후 입원 혹은 외래 2회 이상). 간과 시, <span style="color:red">재분석의 가능성을 배제할 수 없음.</span><br />
</li>
<li>그 외에도 <span style="color:red">결과변수를 비롯한 프로토콜 내의 정의</span>를 모두 확인받는 것이 좋음.</li>
</ul></li>
</ul>
</div>
<div id="환자-선정과정-및-기초특성-추출" class="section level3" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> 환자 선정과정 및 기초특성 추출</h3>
<table>
<colgroup>
<col width="26%" />
<col width="73%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="center">대상환자</td>
<td align="left">진행성 유방암 환자</td>
</tr>
<tr class="even">
<td align="center">연구목적</td>
<td align="left">해당 환자의 비용분석 및 의료이용 연구</td>
</tr>
<tr class="odd">
<td align="center">연구 디자인</td>
<td align="left"><img src="fig3/fig3_1.jpg" /> <br> -index date 선정 기준:</td>
</tr>
<tr class="even">
<td align="center">자료원</td>
<td align="left">건강보험심사평가원 전수데이터</td>
</tr>
<tr class="odd">
<td align="center">환자 선정/배제 기준</td>
<td align="left">□ HR+/HER2- 유방암 환자 <br> <code>-</code> 유방암: 2012.09.01~2017.08.31 기간 중 최소 2번 이상의 유방암(C50) 코드가 포함된 명세서가 있는 환자 <br> <code>-</code> 호르몬수용체 양성 (HR+): 선정된 유방암 환자 중 연구기간(study period) 내에 최소 1회 이상의 내분비요법 처방이 있는 환자 <br> <code>-</code> 사람상피세포성장인자수용체2 음성 (HER2-): 연구기간 내 최소 1회 이상의 HER2+ 치료제 (trastzumab, lapatinib)을 처방받은 환자 제외 <br> □ 폐경 여부 <br> <code>-</code> 폐경 전 환자:사망 전 1년 시점에서 45세 이하이거나, 사망 전 1년 동안 폐경 전 환자에게만 처방 가능한 약제(goserelin, leuprolide)를 사용한 환자 <br> <code>-</code> 폐경 후 환자: 사망 전 1년 시점에서 60세 이상이거나, 사망 전 1년 동안 폐경과 관련한 질병코드인 N95가 포함된 환자</td>
</tr>
<tr class="even">
<td align="center">데이터셋 형태</td>
<td align="left">□ 연구 초반의 단계로, 기존 데이터베이스에 포함된 변수로 시작함</td>
</tr>
</tbody>
</table>
<div id="분석-program" class="section level4 unnumbered">
<h4>분석 Program</h4>
<p>□ 질병으로 환자 정의</p>
<ul>
<li>기본 제공 데이터에서 질병코드 정의</li>
</ul>
<pre><code>data aa.disease_index;
set rawdata.t400_2018q2_23;
if substr(SICK_CD,1,4)=&quot;AC50&quot; then disease1=1; else disease1=0;
if substr(SICK_CD,1,4)=&quot;AC77&quot; then disease2_1=1; else disease2_1=0;
if substr(SICK_CD,1,4)=&quot;AC78&quot; then disease2_2=1; else disease2_2=0;
if substr(SICK_CD,1,4)=&quot;AC79&quot; then disease2_3=1; else disease2_3=0;
if substr(SICK_CD,1,6)=&quot;AC7981&quot; then disease2_4=1; else disease2_4=0;
if disease2_1=1 or disease2_2=1 or disease2_3=1 then disease2=1; else disease2=0;
run;</code></pre>
<p><code>-</code> 40테이블에서 유방암환자 코드 C50이 있는 경우에 대해 disease1으로 코딩함<br />
<code>-</code> 추가로, 전이성 환자에 대한 코드 C77-C79에 대해서도 명세서 단위의 자료원에서 disease2로 코딩<br />
<code>-</code> 이 경우, 모든 ICD-10 코드 앞에 A가 붙는 것을 고려해야함<br />
<code>-</code> 여기서 본인 연구에 활용될 질병의 코드 활용</p>
<ul>
<li>C50이 있는 명세서와 JID 연결</li>
</ul>
<pre><code>proc sql;
create table aa.disease_index2 as
select distinct MID, max(disease1) as disease1, max(disease2) as disease2, max(disease2_1) as disease2_1,
max(disease2_2) as disease2_2, max(disease2_3) as disease2_3, max(disease2_4) as disease2_4
from aa.disease_index
group by 1;
quit;

proc sql;
create table aa.BC_JID as
select distinct a.JID, b.*
from rawdata.T200_2018Q2_23 as a, aa.disease_index2 as b
where a.MID=b.MID;
quit;</code></pre>
<p><code>-</code> 40table에서는 명세서 정보만 있기에 환자식별번호가 있는 20table의 연결이 필요함.<br />
<code>-</code> 이 때, basedata.disease_index에서 명세서 단위로 각 질병코드가 있는 경우를 남긴 데이터셋을 만들어서 (max(disease1)) 20테이블의 환자식별코드(JID)와 연결</p>
<ul>
<li>유방암 코드 2건 이상인 환자만 select</li>
</ul>
<pre><code>data aa.BC_JID_1;
set aa.bc_jid;
if disease1=1; run;

proc sql;
create table aa.BCcount as
select distinct JID, count(distinct MID) as c50_num
from aa.BC_JID_1
group by 1; quit;


data aa.BCcount_delete;
set aa.BCcount;
if c50_num&lt;2 then delete; run;


proc sql;
select count(distinct JID)
from aa.BC_JID; quit;/*391,015*/

proc sql;
select count(distinct JID)
from aa.BC_JID
where disease1=1; quit;/*236,273*/</code></pre>
<p><code>-</code> 해당 연구에서는 환자선정의 타당도를 높이기 위해 해당 질병코드로 처방된 청구건이 2건 이상인 환자만 선정함.</p>
<ul>
<li>위의 과정에서 만들어진 basedata.bc_jid에서 유방암 코드의 명세서만 남긴 후, 좌측 코드를 통해 환자 별 유방암 명세서 개수(c50_num)를 산출한 aa.BCcount 데이터 생성</li>
</ul>
<p><code>-</code> c50_num이 2보다 작은 경우를 삭제</p>
<p><code>-</code> sql코드는 validation을 위한 코드로, 데이터별로 포함된 환자(JID)의 수를 계산함</p>
<p><br></p>
<p>□ 약제 사용내역으로 환자 정의</p>
<pre><code>proc sql;
create table aa.t30_0213 as
select a.MID, a.div_cd, a.cz_item_cd, a.div_ty_cd, a.amt, a.addc_adt_amt, a.tot_injc_ddcnt_exec_fq, a.gnl_cd, b.*
from rawdata.T300_2018Q2_23 as a left join druginfo_new as b
on a.gnl_cd=b.gnl_nm_cd;
quit;

proc sql;
create table aa.t60_0213 as
select a.MID, a.div_ty_cd, a.div_cd,a.amt, a.tot_injc_ddcnt_exec_fq,  a.gnl_cd, b.*
from rawdata.T530_2018Q2_23 as a  left join  druginfo_new as b
on a.gnl_cd=b.gnl_nm_cd;
quit;


data aa.t3053;
set aa.t30_0213 aa.t60_0213; run;</code></pre>
<p><code>-</code> druginfo_new는 연구에 필요한 약품 정보가 반영된 파일로 심평원 제공 자료에서는 단순히 일반명 코드를 바탕으로 정보가 구축되어 있어, 일반명 코드에 해당하는 정보는 druginfo_new 파일에 정리하여 매칭시켜 정리되어야 함.<br />
따라서, 해당 파일에는 약품의 일반명 코드 (GNL_CD)가 필수적으로 포함되어야 함.</p>
<p><code>-</code> 해당 내용에는 내가 원하는 정보를 정리함 (예: 약용량 혹은 고혈압 약의 계열과 관련된 연구일 경우, 미리 어떤 약품코드가 ACE, ARB 등에 속하는지 코딩한 내용 등을 정리)</p>
<p><code>-</code> 예: 심평원 제공 데이터에 특정 gnl_cd가 처방되고, 해당 약제의 처방일수, 하루 처방량만 나와 있기 때문에, 해당 gnl_cd가 어떤 약제이고, 어떤 용량인지에 대한 정보는 별도로 data managing을 통해 연결해야함</p>
<p><code>-</code> 30은 원내, 60은 약국자료이므로 두 자료에 모두 druginfo에 포함된 약품관련 정보를 연결해야함</p>
<p><code>-</code> 자료원 초반에 30, 60을 set 하여 하나로 합치는 작업이 중요함.</p>
<ul>
<li>HR+/HER2- 환자 확인할 것</li>
</ul>
<pre><code>data aa.HR_3053;
set aa.t3053;
if (premeno=1 or AI=1 or ES_inh=1);
run;


proc sql;
create table aa.HR_3053_2 as
select a.JID, b.MID
from rawdata.T200_2018Q2_23 as a, aa.HR_3053 as b where a.MID=b.MID;
quit;</code></pre>
<p><code>-</code> 자료원에서 HR+인 환자를 선정하기 위해서는 premeno, AI, 및 ES_inh으로 정의한 그룹의 약제 복용이 확인된 환자여야 함.</p>
<p><code>-</code> 특정 약제의 premeno, AI 여부에 대한 정보는 druginfo_new에 정의되어야 함</p>
<p><code>-</code> 위에서 해당 약제가 처방된 명세서(MID)만 남긴 aa.HR_3053에서, 20테이블에 명세서(MID) 정보를 바탕으로 환자 식별코드 (JID)를 붙이는 aa.HR_3053_2를 생성함.</p>
<ul>
<li>BC가 2개 이상인 환자 중 HR+ 약제를 사용한 환자</li>
</ul>
<pre><code>proc sql;
create table aa.BC_HR as
select distinct jid
from aa.BC_JID as a, 
aa.HR_3053_2 as b
where a.jid=b.jid; quit;</code></pre>
<p><code>-</code> 위에서 선정된 유방암코드가 2개인 환자(aa.BC_JID) 중 aa.HR_3053_2에서 포함된 환자를 선정</p>
<ul>
<li>HR에서 HER2- 뺄것</li>
</ul>
<pre><code>data aa.HER_3053;
set aa.t3053;
if (Her2pos=1); run;

proc sql;
create table aa.HER_3053_2 as
select a.JID, b.MID
from rawdata.T200_2018Q2_23 as a, aa.HER_3053 as b
where a.MID=b.MID; quit;


proc sort data=aa.HER_3053_2 out=aa.HER_3053_2_1 nodupkey; 
by jid; run;

proc sql;
create table aa.BC_HR_HER as
select *
from aa.BC_HR
where JID not in (select JID from aa.HER_3053_2_1); quit;</code></pre>
<p><code>-</code> 정의된 환자 중 특정 약제를 쓰지 않는 경우에 활용할 수 있는 코드임</p>
<p><code>-</code> 위에서 해당 약제가 처방된 명세서(MID)만 남긴 aa.HER_3053에서, 20테이블에 명세서(MID) 정보를 바탕으로 환자 식별코드 (JID)를 붙이는 aa.HER_3053_2를 생성함.</p>
<p><code>-</code> 환자 ID 당 1줄만 남도록 중복제거</p>
<p>@ 위에서 조건을 만족한 aa.BC_HR 자료원 중 특정 약제를 쓴 환자 정보는 제외함</p>
<p><br></p>
<p>□ 행위(예: 수술 등)로 환자 선정</p>
<ul>
<li>30 table에 포함된 수가코드 활용</li>
</ul>
<pre><code>data aa.t30dz_1;
set rawdata.t300_2018q1_26;
suga=substr(div_cd,1,5);
if suga in (&#39;R3505&#39;) then trt=1;
run;</code></pre>
<p><code>-</code> 30table 원자료 (t300_2018q1_26)에서 수가코드를 의미하는 ‘div_cd’ 코드 활용</p>
<p><code>-</code> 연구별 활용하는 수가코드에 따라, substr이라는 코드를 활용하여 행위 여부를 코딩할 수 있음.</p>
<p><br></p>
<p>□ 입.내원 기록으로 추가 정의<br />
- 일정 조건 중 연구 디자인에 따라 병원방문기록을 추가적으로 고려하기도 함<br />
- 해당 예시에서는 index date 이후 6개월 이내에 1회 입원 및 1회 외래방문인 경우를 선정하는 것으로 가정함</p>
<ul>
<li>모든 명세서 중 index date 이후 6개월(180일 명세서만 남기기)</li>
</ul>
<pre><code>proc sql;
create table pt_select as
select *
from index_data 
where (index_date) &lt; recu_fr_dt &lt;=(index_date+180); quit; 


data pt_select1;
set pt_select;
if fom_tp_cd=&#39;021&#39; then hos=1; else hos=0;
if fom_tp_cd=&#39;031&#39; then out=1; else out=0;run;

proc sql;
create table pt_select2 as
select distinct jid, sum(hos) as hos_num, sum(out) as out_num
from pt_select1
group by jid;quit;

data pt_select3;
set pt_select2;
if (hos_num&gt;=1 and out_num&gt;=1);run;

proc sql;
create table pt_select4 as
select distinct jid
from pt_select3;quit;</code></pre>
<p><code>-</code> 여기서 index data에는 앞서 선정된 환자의 index_date 정보 및 모든 명세서에 대한 요양개시일자 (recu_fr_dd를 날짜변수로 변환필요), 서식구분코드 (심평원: fom_tp_cd)가 있어야 함 (20table처럼 명세서당 1줄만 있어야 함)</p>
<p><code>-</code> 서식구분 코드로 입원 및 외래 명세서 구분<br />
* 특정 질병코드 및 약제 사용내용이 포함된 입원 및 외래 명세서가 필요하다면, 해당 과정 앞에 30 및 53table을 활용하여 조건에 만족하는 명세서정보를 남긴 후 좌측 코드 수행</p>
<p><code>-</code> 환자 기준 발생한 외래 및 입원 명세서 개수 합산</p>
<p><code>-</code> 외래 &amp; 입원이 1회 이상인 환자만 남김</p>
<p><code>-</code> 환자 정보만 추출</p>
<p><br></p>
<p>□ 기초 특성<br />
환자 선정 이후 단계</p>
<ul>
<li>Table 1</li>
</ul>
<pre><code>data aa.data2;
set aa.data2;
format recu_fr_dt yymmdd10.;
recu_fr_dt=mdy(substr(recu_fr_dd,5,2),substr(recu_fr_dd,7,2),substr(recu_fr_dd,1,4));
run;

proc sql;
create table aa.basedata as
select *
from aa.data2
where (second_date-365) le recu_fr_dt lt second_date; quit; </code></pre>
<p><code>-</code> 포함환자의 모든 명세서 정보 (20,30,53 table 정보 포함)가 담긴 파일(aa.data2)</p>
<p># aa.data2는 활용도가 높으므로 별도의 라이브러리에 저장하는 것이 분석시 편리</p>
<p><code>-</code> 해당 파일 중 index date (현재 second_date로 코딩) 기준으로 1년 전까지의 기록만 남김 (second_date-365&lt;=recu_fr_dt&lt;second_date)</p>
<p><code>-</code> 이후 설명에서, index date 기준 1년 전 기간을 pre-index로 명명함</p>
<p>@ 참고) 부등호 관련 코드</p>
<table>
<tbody>
<tr class="odd">
<td align="center">Operator</td>
<td align="left">Description</td>
</tr>
<tr class="even">
<td align="center">=, eq</td>
<td align="left">equals</td>
</tr>
<tr class="odd">
<td align="center">^=, &lt;&gt;, ne</td>
<td align="left">does not equals</td>
</tr>
<tr class="even">
<td align="center">&gt;, gt</td>
<td align="left">is greater than</td>
</tr>
<tr class="odd">
<td align="center">&lt;, lt</td>
<td align="left">is less than</td>
</tr>
<tr class="even">
<td align="center">&gt;=, ge</td>
<td align="left">is grreater than or equal to</td>
</tr>
<tr class="odd">
<td align="center">&lt;=, le</td>
<td align="left">is less than or equal to</td>
</tr>
</tbody>
</table>
<ul>
<li>co-morbidity</li>
</ul>
<pre><code>proc sql;
create table aa.table1_disease as
select a.JID, a.MID, b.SICK_CD
from aa.basedata as a left join rawdata.t400_2018q2_23 as b
on a.MID=b.MID;quit;

data aa.table1_disease1;
set aa.table1_disease;
sick=substr(sick_cd,1,4);
sick5=substr(sick_cd,1,5);
sick6=substr(sick_cd,1,6);
if sick in (&quot;AF32&quot; &quot;AF33&quot;) then depr=1; else depr=0;
if sick in (&quot;AE10&quot; &quot;AE11&quot; &quot;AE12&quot; &quot;AE13&quot; &quot;AE14&quot;) then diab=1; else diab=0;
if sick in (&quot;AF00&quot; &quot;AF01&quot; &quot;AF02&quot; &quot;AF03&quot; &quot;AG30&quot;) or sick5 in (&quot;AF051&quot; &quot;AG311&quot; &quot;AG319&quot;) or sick6=&quot;AG3182&quot; then demen=1; else demen=0;
if sick in (&quot;AI10&quot; &quot;AI11&quot; &quot;AI12&quot; &quot;AI13&quot; &quot;AI14&quot; &quot;AI15&quot;) then hyper=1;else hyper=0;
if sick in (&quot;AM80&quot; &quot;AM81&quot;) then osteo=1; else osteo=0;
if sick=&quot;AD64&quot; then anemia=1; else anemia=0; run;

proc sql;
create table aa.table1_disease2 as
select distinct JID, max(anemia) as anemia, max(depr) as depr, max(diab) as diab, max(osteo) as osteo, max(hyper) as hyper, max(demen) as demen
from aa.table1_disease1
group by 1; quit;</code></pre>
<p><code>-</code> 환자의 basedata에 상병코드를 명세서 번호를 기준으로 40table과 연결함</p>
<p><code>-</code> 질환에 따라 정의될 수 있는 ICD-10코드 길이가 상이하므로 길이별 코드를 생성함</p>
<p><code>-</code> 현재 예시는 우울증, 당뇨, 치매, 고혈압, 골다공증, 빈혈</p>
<p>*차후 개별 연구에 활용시 sick, sick5, sick6을 모두 활용한 치매(dement) 코드 참고 권장</p>
<p><code>-</code> 해당 기간 동안 각 질병여부를 확인하기 위하여 max 코드를 활용하였으며, 환자단위 (group by 1←select distinct 구문 이후 변수 중 첫 번째인 JID를 의미)로 구분하도록 정의함</p>
<ul>
<li>CCI 정의</li>
</ul>
<pre><code>
%macro cci(a);

proc sql;
create table cci as
select JID,
    /*심근경색*/
    (case when substr(left(sick_cd),2,3) in (&#39;I21&#39;, &#39;I22&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;I252&#39;) then 1 else 0 end ) as DI1,
        /* 울혈성 심부전 */  
    (case when substr(left(sick_cd),2,3) in (&#39;I43&#39;, &#39;I50&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;I099&#39;, &#39;I110&#39;, &#39;I130&#39;, &#39;I132&#39;, &#39;I255&#39;, &#39;I420&#39;, &#39;I425&#39;, &#39;I426&#39;, &#39;I427&#39;, &#39;I428&#39;, &#39;I429&#39;, &#39;P290&#39;) then 1 else 0 end ) as DI2,
    /* 말초혈관질환 */
    (case when substr(left(sick_cd),2,3) in (&#39;I70&#39;, &#39;I71&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;I731&#39;, &#39;I738&#39;, &#39;I739&#39;, &#39;I771&#39;, &#39;I790&#39;, &#39;I792&#39;, &#39;K551&#39;, &#39;K558&#39;, &#39;K559&#39;, &#39;Z958&#39;, &#39;Z959&#39;) then 1 else 0 end ) as DI3,
    /* 뇌혈관질환 */
    (case when substr(left(sick_cd),2,3) in (&#39;G45&#39;, &#39;G46&#39;, &#39;I60&#39;, &#39;I61&#39;, &#39;I62&#39;, &#39;I63&#39;, &#39;I64&#39;, &#39;I65&#39;, &#39;I66&#39;, &#39;I67&#39;, &#39;I68&#39;, &#39;I69&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;H340&#39;) then 1 else 0 end ) as DI4,
    /* 치매 */
    (case when substr(left(sick_cd),2,3) in (&#39;F00&#39;, &#39;F01&#39;, &#39;F02&#39;, &#39;F03&#39;, &#39;G30&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;F051&#39;, &#39;G311&#39;) then 1 else 0 end ) as DI5,
    /* 만성폐질환 */
    (case when substr(left(sick_cd),2,3) in (&#39;J40&#39;, &#39;J41&#39;, &#39;J42&#39;, &#39;J43&#39;, &#39;J44&#39;, &#39;J45&#39;, &#39;J46&#39;, &#39;J47&#39;, &#39;J60&#39;, &#39;J61&#39;, &#39;J62&#39;, &#39;J63&#39;, &#39;J64&#39;, &#39;J65&#39;, &#39;J66&#39;, &#39;J67&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;I278&#39;, &#39;I279&#39;, &#39;J684&#39;, &#39;J701&#39;, &#39;J703&#39;) then 1 else 0 end ) as DI6,

    /* 결합조직질환 */
    (case when substr(left(sick_cd),2,3) in (&#39;M05&#39;, &#39;M06&#39;, &#39;M32&#39;, &#39;M33&#39;, &#39;M34&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;M315&#39;, &#39;M351&#39;, &#39;M353&#39;, &#39;M360&#39;) then 1 else 0 end ) as DI7,
    /* 소화궤양 */
    (case when substr(left(sick_cd),2,3) in (&#39;K25&#39;, &#39;K26&#39;, &#39;K27&#39;, &#39;K28&#39;) then 1 else 0 end ) as DI8,
    /* 경증 간질환 */
    (case when substr(left(sick_cd),2,3) in (&#39;B18&#39;, &#39;K73&#39;, &#39;K74&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;K700&#39;, &#39;K701&#39;, &#39;K702&#39;, &#39;K703&#39;, &#39;K709&#39;, &#39;K713&#39;, &#39;K714&#39;, &#39;K715&#39;, &#39;K717&#39;,&#39;K760&#39;, &#39;K762&#39;, &#39;K763&#39;, &#39;K764&#39;, &#39;K768&#39;, &#39;K769&#39;, &#39;Z944&#39;) then 1 else 0 end ) as DI9,
    /* 합병증이 없는 당뇨병 */
    (case when substr(left(sick_cd),2,3) in (&#39;E10&#39;, &#39;E11&#39;, &#39;E12&#39;, &#39;E13&#39;, &#39;E14&#39;) then 1
when substr(left(sick_cd),2,4) in (&#39;E100&#39;, &#39;E101&#39;, &#39;E106&#39;, &#39;E108&#39;, &#39;E109&#39;, &#39;E110&#39;, &#39;E111&#39;, &#39;E116&#39;, &#39;E118&#39;, &#39;E119&#39;, &#39;E120&#39;, &#39;E121&#39;, &#39;E126&#39;, &#39;E128&#39;, &#39;E129&#39;, &#39;E130&#39;, &#39;E131&#39;, &#39;E136&#39;, &#39;E138&#39;, &#39;E139&#39;, &#39;E140&#39;, &#39;E141&#39;, &#39;E146&#39;, &#39;E148&#39;, &#39;E149&#39;) then 1 else 0 end ) as DI10,
    /* 합병증 동반 당뇨병 */
    (case when substr(left(sick_cd),2,4) in (&#39;E102&#39;, &#39;E103&#39;, &#39;E104&#39;, &#39;E105&#39;, &#39;E107&#39;, &#39;E112&#39;, &#39;E113&#39;, &#39;E114&#39;, &#39;E115&#39;, &#39;E117&#39;, &#39;E122&#39;, &#39;E123&#39;, &#39;E124&#39;, &#39;E125&#39;, &#39;E127&#39;, &#39;E132&#39;, &#39;E133&#39;, &#39;E134&#39;, &#39;E135&#39;, &#39;E137&#39;, &#39;E142&#39;, &#39;E143&#39;, &#39;E144&#39;, &#39;E145&#39;, &#39;E147&#39;) then 1 else 0 end ) as DI11,
    /* 반신마비 */
    (case when substr(left(sick_cd),2,3) in (&#39;G81&#39;, &#39;G82&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;G041&#39;, &#39;G114&#39;, &#39;G801&#39;, &#39;G802&#39;, &#39;G830&#39;, &#39;G831&#39;, &#39;G832&#39;, &#39;G833&#39;, &#39;G834&#39;, &#39;G839&#39;) then 1 else 0 end ) as DI12,
    /* 신장질환 */
    (case when substr(left(sick_cd),2,3) in (&#39;N18&#39;, &#39;N19&#39;) then 1
              when substr(left(sick_cd),2,4) in (&#39;I120&#39;, &#39;I131&#39;, &#39;N032&#39;, &#39;N033&#39;, &#39;N034&#39;, &#39;N035&#39;, &#39;N036&#39;, &#39;N037&#39;, &#39;N052&#39;, &#39;N053&#39;, &#39;N054&#39;, &#39;N055&#39;, &#39;N056&#39;, &#39;N057&#39;, &#39;N250&#39;, &#39;Z490&#39;, &#39;Z491&#39;, &#39;Z492&#39;, &#39;Z940&#39;, &#39;Z992&#39;) then 1 else 0 end ) as DI13,
    /* 암 exp BC */
    (case when substr(left(sick_cd),2,3) in (&#39;C00&#39;, &#39;C01&#39;, &#39;C02&#39;, &#39;C03&#39;, &#39;C04&#39;, &#39;C05&#39;, &#39;C06&#39;, &#39;C07&#39;, &#39;C08&#39;, &#39;C09&#39;, &#39;C10&#39;, &#39;C11&#39;, &#39;C12&#39;, &#39;C13&#39;, &#39;C14&#39;, &#39;C15&#39;, &#39;C16&#39;, &#39;C17&#39;, &#39;C18&#39;, &#39;C19&#39;, &#39;C20&#39;, &#39;C21&#39;, &#39;C22&#39;, &#39;C23&#39;, &#39;C24&#39;, &#39;C25&#39;, &#39;C26&#39;, &#39;C30&#39;, &#39;C31&#39;, &#39;C32&#39;, &#39;C33&#39;, &#39;C34&#39;, &#39;C37&#39;, &#39;C38&#39;, &#39;C39&#39;, &#39;C40&#39;, &#39;C41&#39;, &#39;C43&#39;, &#39;C45&#39;, &#39;C46&#39;, &#39;C47&#39;,&#39;C48&#39;,&#39;C49&#39;, &#39;C51&#39;,&#39;C52&#39;, &#39;C53&#39;, &#39;C54&#39;, &#39;C55&#39;, &#39;C56&#39;, &#39;C57&#39;, &#39;C58&#39;, &#39;C60&#39;, &#39;C61&#39;, &#39;C62&#39;, &#39;C63&#39;, &#39;C64&#39;, &#39;C65&#39;, &#39;C66&#39;, &#39;C67&#39;, &#39;C68&#39;, &#39;C69&#39;, &#39;C70&#39;, &#39;C71&#39;, &#39;C72&#39;, &#39;C73&#39;, &#39;C74&#39;, &#39;C75&#39;, &#39;C76&#39;, &#39;C81&#39;, &#39;C82&#39;, &#39;C83&#39;, &#39;C84&#39;, &#39;C85&#39;, &#39;C88&#39;, &#39;C90&#39;, &#39;C91&#39;, &#39;C92&#39;, &#39;C93&#39;, &#39;C94&#39;, &#39;C95&#39;, &#39;C96&#39;, &#39;C97&#39;) then 1 else 0 end ) as DI14,
    /* 간질환 */
    (case when substr(left(sick_cd),2,4) in (&#39;I850&#39;, &#39;I859&#39;, &#39;I864&#39;, &#39;I982&#39;, &#39;K704&#39;, &#39;K711&#39;, &#39;K721&#39;, &#39;K729&#39;, &#39;K765&#39;, &#39;K766&#39;, &#39;K767&#39;) then 1 else 0 end ) as DI15,
    /* 전이성 고형암 */
    (case when substr(left(sick_cd),2,3) in (&#39;C77&#39;, &#39;C78&#39;, &#39;C79&#39;, &#39;C80&#39;) then 1 else 0 end ) as DI16,
    /* 후천성면역결핍즏 */
    (case when substr(left(sick_cd),2,3) in (&#39;B20&#39;, &#39;B21&#39;, &#39;B22&#39;, &#39;B24&#39;) then 1 else 0 end ) as DI17
from &amp;a;
create table  cci2 as
select distinct JID, 
    max(DI1) as DI1, 
    max(DI2) as DI2, 
    max(DI3) as DI3, 
    max(DI4) as DI4, 
    max(DI5) as DI5, 
    max(DI6) as DI6, 
    max(DI7) as DI7, 
    max(DI8) as DI8, 
    max(DI9) as DI9, 
    max(DI10) as DI10, 
    max(DI11) as DI11, 
    max(DI12) as DI12, 
    max(DI13) as DI13, 
    max(DI14) as DI14, 
    max(DI15) as DI15, 
    max(DI16) as DI16, 
    max(DI17) as DI17
from cci 
group by JID;
quit;

data aa.cci2; /*생성된 cci 데이터*/
set cci2;
cci=(DI1+DI2+DI3+DI4+DI5+DI6+DI7+DI8+DI9+DI10)*1+(DI11+DI12+DI13+DI14)*2+(DI15)*3+(DI16+DI17)*6;
keep JID cci;
run;

%mend cci;
%cci( aa.table1_disease );</code></pre>
<p><code>-</code> 이미 확인된 매크로 코드이므로, 좌측 코드를 그대로 활용하면 됨. 해당 코드는 업데이트 된 CCI 가중치를 활용한 것임</p>
<p><code>-</code> 다만, 코드 하단의 다음 밑줄 친 2부분을 수정해 주어야 함.</p>
<pre><code>data aa.cci2; /*생성된 cci 데이터*/
set cci2;
cci=(DI1+DI2+DI3+DI4+DI5+DI6+DI7+DI8+DI9+DI10)*1+(DI11+DI12+DI13+DI14)*2+(DI15)*3+(DI16+DI17)*6;
keep JID cci;
run;

%mend cci;
%cci(aa.table1_disease); /*pre-index 자료*/</code></pre>
<p><code>-</code> “aa.table1_disease”에 담긴 정보를 기반으로 cci가 계산되므로 해당 자료원에는 환자식별정보 (JID), 상병코드(sick_cd)가 필수로 있어야함.<br />
좌측 자료원에서는 pre-index 기간의 모든 명세서정보이므로, 명세서정보 (MID)도 포함됨</p>
<ul>
<li>co-medication 추가</li>
</ul>
<pre><code>data aa.table1_comedi;
set aa.basedata;
if gnl_cd in (&quot;359001ATR&quot; &quot;359002ATB&quot; &quot;359002ATR&quot; &quot;359002BIJ&quot; &quot;359003ATR&quot; &quot;359003BIJ&quot; &quot;359004ATB&quot; &quot;359007ATR&quot; &quot;359008ATR&quot; &quot;359030BIJ&quot; &quot;359031BIJ&quot; &quot;359032BIJ&quot; &quot;380500ATB&quot; &quot;440600ACH&quot; &quot;517100ATR&quot; &quot;564000ATR&quot; &quot;564100ATR&quot; &quot;359005ATB&quot; &quot;359006ATB&quot;) then oxycodon=1; else oxycodon=0;
if gnl_cd in (&quot;197201BIJ&quot; &quot;197202BIJ&quot; &quot;197230BIJ&quot; &quot;197231BIJ&quot; &quot;197301ACR&quot; &quot;197301ATR&quot; &quot;197301BIJ&quot; &quot;197302ACR&quot; &quot;197302ATR&quot; &quot;197302BIJ&quot; &quot;197303BIJ&quot; &quot;197303CSP&quot; &quot;197304BIJ&quot; &quot;197305ATB&quot; &quot;197305BIJ&quot; &quot;197306BIJ&quot; &quot;197307BIJ&quot; &quot;197308BIJ&quot; &quot;197311BIJ&quot; &quot;197330BIJ&quot; &quot;197331BIJ&quot; &quot;197332BIJ&quot; &quot;197333BIJ&quot; &quot;197334BIJ&quot; &quot;197335BIJ&quot; &quot;197336BIJ&quot; &quot;197337BIJ&quot; &quot;197338BIJ&quot; &quot;197339BIJ&quot; &quot;197340BIJ&quot; &quot;197301ATB&quot; &quot;197301CSP&quot; &quot;197302CSP&quot; &quot;197304CSP&quot;) then morphine=1;else morphine=0;
run;

proc sql;
create table aa.table1_comedi1 as
select distinct jid, max(oxycodon) as oxycodon, max(morphine) as morphine, max(codeine) as codeine, max(fentanyl) as fentanyl
from aa.table1_comedi
group by jid; quit;</code></pre>
<p><code>-</code> 환자의 pre-index 기간에 사용한 약물 정보를 추출함.<br />
현재 예시에서는 oxycodon 및 morphine을 활용함</p>
<p><code>-</code>pre-index 기간동안의 복용여부가 필요하므로 환자정보를 기준으로 복용여부를 남김</p>
<ul>
<li>생성된 기초특성 자료 합치기</li>
</ul>
<pre><code>proc sort data=aa.basedata out=aa.table1_final nodupkey;
by jid index_age;run;



proc sql;
create table aa.table1_final1 as
select distinct a.JID, a.index_age, b.anemia, b.depr, b.diab, b.demen, b.hyper, b.osteo, 
c.cci, 
d.oxycodon,d.morphine
from aa.table1_final as a left join aa.table1_disease2 as b on a.JID=b.JID
left join aa.cci2 as c on a.JID=c.JID
left join aa.table1_comedi2 as d on a.JID=d.JID; quit;

data aa.table1_final2 ;
set aa.table1_final1 ;
if cci=0 then cci_group=1;
else if cci&gt;4 then cci_group=3;
else cci_group=2;
run;

proc contents data=aa.table1_final2;
run;

proc freq data=aa.table1_final2;
table (cci_group anemia depr diab demen hyper osteo oxycodon morphine)/cmh; run;</code></pre>
<p><code>-</code> 환자들의 index_date 시점의 연령(pat_age)를 index_age로 정의하였기에 aa.basedata를 기준으로 환자 당 1줄만 남길 수 있게 nodupkey를 적용하여 정렬<br />
* age 및 성별은 20table에 있음</p>
<p><code>-</code> 환자 별로 생성된 테이터를 left join함</p>
<p><code>-</code> cci_group 코딩</p>
<p><code>-</code> 하단의 빈도분석 코딩 수행을 위해 proc contents를 통해 포함된 변수명 확인</p>
<p><code>-</code> 포함 변수에 대한 빈도분석 수행시 cmh; 조건문을 통해 빈도 분석의 통계적 유의미성을 확인할 수 있음</p>
<ul>
<li>특정 그룹 제외 분석시</li>
</ul>
<pre><code>proc freq data=aa.table1_final2;
table (anemia depr diab demen hyper osteo oxycodon morphine)/cmh;
where cci_group^=0 ; run;

proc means data=aa.table1_final2;
var index_age cci; run;</code></pre>
<p><code>-</code> 아래 where 구문에서 ^=0 을 입력하면, cci_group 중 0에 해당하는 그룹은 제외하고 분석됨.<br />
* 특정 조건에 해당하는 분석시, ‘=’ 사용</p>
<p><code>-</code> 평균은 proc means를 사용</p>
<ul>
<li>그룹별 평균 분석 (예: 성별)</li>
</ul>
<pre><code>proc means data=aa.table1_final2;
var index_age;
class sex; run;</code></pre>
<p><code>-</code> 그룹별 분석시 ‘class’ 문을 활용함</p>
<p>표 4 기초특성 분석표 예시</p>
<table>
<thead>
<tr class="header">
<th align="center">Variables</th>
<th align="center">Overall Population(n=2,208)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><strong>Age, mean ± SD</strong></td>
<td align="center">55.0 ±10.3</td>
</tr>
<tr class="even">
<td align="center"><strong>CCI (mean ± SD)</strong></td>
<td align="center">6.3±3.1</td>
</tr>
<tr class="odd">
<td align="center"><strong>CCI group,n(%)</strong></td>
<td align="center">2,208(100.0)</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td align="center">160(7.3)</td>
</tr>
<tr class="odd">
<td align="center">1-3</td>
<td align="center">311(14.1)</td>
</tr>
<tr class="even">
<td align="center">4+</td>
<td align="center">1737(78.7)</td>
</tr>
<tr class="odd">
<td align="center"><strong>Comorbidities,n(%)§</strong></td>
<td align="center">2,207(100.0)</td>
</tr>
<tr class="even">
<td align="center">Depression</td>
<td align="center">304(13.8)</td>
</tr>
<tr class="odd">
<td align="center">Diabetes</td>
<td align="center">414(18.8)</td>
</tr>
<tr class="even">
<td align="center">Dementia</td>
<td align="center">38(1.7)</td>
</tr>
<tr class="odd">
<td align="center">Hypertension</td>
<td align="center">624(28.3)</td>
</tr>
<tr class="even">
<td align="center">Osteoporosis</td>
<td align="center">781(35.4)</td>
</tr>
<tr class="odd">
<td align="center"><strong>Analgesics, n(%)§</strong></td>
<td align="center">2,207(100.0)</td>
</tr>
<tr class="even">
<td align="center">Oxycodone</td>
<td align="center">543(24.6)</td>
</tr>
<tr class="odd">
<td align="center">Morphine</td>
<td align="center">239(10.8)</td>
</tr>
<tr class="even">
<td align="center">§ One patient had missing data.</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
</div>
</div>
<div id="비용-및-의료자원-이용" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> 비용 및 의료자원 이용</h2>
<p><code>-</code> 수록 내용: 의료비용 및 의료자원 이용에 대해 입원/ 외래별 10대분류로 분류하여 산출<br />
- 분석 전 고려사항<br />
□ 원외처방에 대한 약품비용 계산 관련<br />
<code>-</code> 심평원의 병원자료 53테이블과 약국 30테이블은 기본적으로 같은 내용을 담고있으나, 포함내용이 상이할 수 있음 (하단 표 참고)</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="center">병원 53 테이블</th>
<th align="center">약국 30 테이블</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">의사의 처방 내역</td>
<td align="center">O⑴</td>
<td align="center">X</td>
</tr>
<tr class="even">
<td align="left">실제 조제 내역</td>
<td align="center">X</td>
<td align="center">O⑴</td>
</tr>
<tr class="odd">
<td align="left">약국 조제료</td>
<td align="center">X</td>
<td align="center">O</td>
</tr>
</tbody>
</table>
<p>⑴ 일반적으로는 두 내역이 동일하나, 실제 조제 내역이 다를 경우도 있음</p>
<p><code>-</code>두 자료원을 동시에 신청할 경우 중복된 자료원이 제공되므로, 실제 처방 &amp; 조제내역의 비교 혹은 실제 의약품 처방행태 등을 확인하는 목적을 제외하면 일반적으로 <span style="color:red">원외처방 내역은 병원 53테이블을 신청.</span></p>
<p>□ 총액과 subtotal 계산 관련<br />
<code>-</code> 심평원의 30테이블의 경우, 심사 결정된 건이 모두 누적되어 있으나 지급구분변수 상 지급된 자료원이 추출되었을 가능성이 높음. 따라서, 제공되는 데이터는 심사 결정된 건으로 추정됨<br />
<code>-</code> 그럼에도 불구하고, 경우에 따라 명세서 단위 총액(20테이블의 심사결정금액)과 해당 명세서 내의 행위별 단가의 합(30테이블의 항목별 비용 합)이 다르므로, 연구에서 항목별 비용을 세분화하여 산출시 총액을 20테이블로 할 경우 합이 다를 수 있음. (원인은 심평원에 문의 중)<br />
<code>-</code> 질병 중 포괄수가제 적용되는 경우는 이 때 수행된 구체적인 행위 확인이 불가함. 따라서 연구의 대상 질환의 특성 확인 필요</p>
<p>□ 입원 비용 산출 과정에서 주의 사항★<br />
<code>-</code> 입원 명세서의 경우, 병원에서 비용 청구를 위해 실제로 퇴원이 아님에도 불구하고 퇴원처리 후 즉시 입원하는 행정절차를 수행하기도 함. 따라서 이러한 경우가 제대로 반영되지 않으면, 환자의 입원횟수는 과대추정 입원기간은 과소추정될 수 있음 (아래 예시 참고)</p>
<table>
<thead>
<tr class="header">
<th align="center">JJD</th>
<th align="center">recu_fr_dd</th>
<th align="center">recu_to_dd</th>
<th align="center">lag_hos_off</th>
<th align="center">gap_epi</th>
<th align="center">입원 기간</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">2012-01-01</td>
<td align="center">2012-01-14</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">14</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">2012-01-15</td>
<td align="center">2012-01-20</td>
<td align="center">2012-01-14</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">2012-01-31</td>
<td align="center">2012-02-13</td>
<td align="center">2012-01-20</td>
<td align="center">11</td>
<td align="center">14</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center">↓</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr class="odd">
<td align="center">JJD</td>
<td align="center">recu_fr_dd</td>
<td align="center">recu_to_dd</td>
<td align="center">lag_hos_off</td>
<td align="center">gap_epi</td>
<td align="center"></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">2012-01-01</td>
<td align="center">2012-01-20</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">20</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">2012-01-31</td>
<td align="center">2012-02-13</td>
<td align="center">2012-01-20</td>
<td align="center">11</td>
<td align="center">14</td>
</tr>
</tbody>
</table>
<p>□ 질병 특이적인 비용 산출시<br />
<code>-</code> 명세서에 따라, 질병코드만으로 정의할 경우 대상 질병의 명세서가 누락될 수 있음 (실제로 유방암 환자의 비용연구에서, 명세서 상의 유방암 ICD-10 코드가 없었음에도 tamoxifen이라는 유방암 치료 약물이 처방된 경우가 있음). 따라서 질병 특이적인 비용을 산출하기 위해 명세서를 정의하는 과정은 임상전문가의 자문을 받는 것이 좋음.</p>
<p>□ 응급실 방문 비용<br />
<code>-</code> 응급실 방문비용은 명세서 중 수가코드 중 응급실 방문 관련 코드(AC101, AC103, AC105)가 포함되었거나, 응급의학과 코드(dsbit_cd=’24’)가 포함된 건을 이용함.<br />
<code>-</code> 여기에서 입원 환자 중 응급실을 경유한 입원에 대한 명세서도 응급방문 정의시 고려될 수 있음. 하지만 이 경우 이로 인한 입원비용이 반영되어, 해당 조건 여부에 따라 결과의 편차가 크므로 연구에 따라 포함여부의 결정이 필요함.</p>
<div id="비용-산출" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> 비용 산출</h3>
<p><code>-</code> 대상 환자는 위의 환자선정에 포함된 환자이며, 해당 환자의 입원/외래 별 비용에 대하여 10대 분류 별 분석을 수행함 (아래 코드 참고)</p>
<p><표 > 10대 분류를 위한 참고 표 (심평원 기준)</p>
<table>
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">코드명</th>
<th align="left">정의</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CZ_ITEM_CD</td>
<td align="left">명세서항별목코드 <br> (항코드+목코드:각 항코드마다 목코드 분류가 있어 항코드 와 목코드를 조합하여 진료내역의 일반적 특성을 파악할 수 있음)</td>
</tr>
<tr class="even">
<td align="left"><strong>항코드</strong></td>
<td align="left"><strong>목코드</strong></td>
</tr>
<tr class="odd">
<td align="left">01:진찰료</td>
<td align="left">(01:초진,02:재진,03:응급및회송료등)</td>
</tr>
<tr class="even">
<td align="left">02:입원료</td>
<td align="left">(01:일반,02:내과,정신과,만8세미만의소아,03: 중환자실,04:격리병실,10:기본식대,11:가산식 대,99:기타입원료)</td>
</tr>
<tr class="odd">
<td align="left">03:투약료</td>
<td align="left">(01:내복약,02:외용약,03:처방전)</td>
</tr>
<tr class="even">
<td align="left">04:주사료</td>
<td align="left">(01:주사,99:기타)</td>
</tr>
<tr class="odd">
<td align="left">05:마취료</td>
<td align="left">(01:마취)</td>
</tr>
<tr class="even">
<td align="left">06:이학요법료</td>
<td align="left">(01:이학요법료)</td>
</tr>
<tr class="odd">
<td align="left">07:정신요법료</td>
<td align="left">(01:정신요법료)</td>
</tr>
<tr class="even">
<td align="left">08:처치 및 수술료</td>
<td align="left">(01:처치및수술,(치과)보통처치외처치항목,02:(치과)절개외수술항목03:캐스트,99:치과기타)</td>
</tr>
<tr class="odd">
<td align="left">09:검사료</td>
<td align="left">(01:자체검사,02:위탁검사)</td>
</tr>
<tr class="even">
<td align="left">10:영상진단 및 방사선치료료</td>
<td align="left">(01:진단, 02:치료)</td>
</tr>
<tr class="odd">
<td align="left">L: 요양병원정액</td>
<td align="left">(01:요양병원정액수가)</td>
</tr>
<tr class="even">
<td align="left">S: 특수장비</td>
<td align="left">(01:CT진단,02:MRI진단,03:PET진단)</td>
</tr>
<tr class="odd">
<td align="left">V:보훈 등100/100본인부담</td>
<td align="left">(01:의약품,02:치료재료,03:진료행위)</td>
</tr>
<tr class="even">
<td align="left">W:비급여(*한방 경우는 다름)</td>
<td align="left">(01:의약품,02:치료재료,03:진료행위)</td>
</tr>
<tr class="odd">
<td align="left">X:정신과 정액</td>
<td align="left">(01:의료급여 정신질환 정액수가(외래,낮병 동,입원,외박수가), <br> 02:투약 1일당 정액수가)</td>
</tr>
</tbody>
</table>
<ul>
<li>분석 program</li>
</ul>
<pre><code>data aaa.pre_index_cost1;
set aaa.pre_index1;
if cz_item_cd=&quot;&quot; then cz_item_cd=&#39;9999&#39;;
if cz_item_cd=&#39;9999&#39; then addc_adt_amt=amt;

item=substr(cz_item_cd,1,2);
item2=substr(cz_item_cd,1,4);
item3=substr(div_cd,1,3);

if (item in (&#39;03&#39; &#39;04&#39; &#39;99&#39;) and div_ty_cd=&#39;3&#39;) then cost_1=1; else cost_1=0; *약품비;
if (cost_1=1 and treatmedi=1) then cost_1_txt=1; else cost_1_txt=0; *치료약품비;
if (item in (&#39;03&#39; &#39;04&#39; &#39;99&#39;) and div_ty_cd^=&#39;3&#39;) then cost_2=1; else cost_2=0; *투약주사료;
if item3 in (&#39;AA1&#39; &#39;AA2&#39;) then cost_3=1; else cost_3=0; *진찰료;
if item=&#39;09&#39; then cost_4=1; else cost_4=0;  *검사료;
if item=&#39;02&#39; then cost_5=1; else cost_5=0; *입원료;
if item=&#39;08&#39; then cost_6=1; else cost_6=0;  *처치 및 수술료;
if item in (&#39;10&#39; &#39;SS&#39;) then cost_7=1; else cost_7=0; *영상진단 및 방사선;
if (cost_1=0 and cost_2=0 and cost_3=0 and cost_4=0 and cost_5=0 and cost_6=0 and cost_7=0) then cost_8=1; else cost_8=0; *others;
run;

proc sort data=aaa.pre_index_cost1;
by jid recu_fr_Dt;
run;</code></pre>
<p><code>-</code> aaa.pre_index1에 포함된 자료는 대상 환자의 원하는 연구기간 동안의 모든 명세서에 대해 30 및 53table의 정보가 담긴 dataset</p>
<p><code>-</code> 10대 분류로 분리하기 위한 과정이며, 이 부분은 연구에 따라 카테고리가 변동될 수 있음</p>
<p><br></p>
<pre><code>data aaa.pre_index_cost2;
set aaa.pre_index_cost1;
cost_11=cost_1*ADDC_ADT_AMT;
cost_22=cost_2*ADDC_ADT_AMT;
cost_33=cost_3*ADDC_ADT_AMT;
cost_44=cost_4*ADDC_ADT_AMT;
cost_55=cost_5*ADDC_ADT_AMT;
cost_66=cost_6*ADDC_ADT_AMT;
cost_77=cost_7*ADDC_ADT_AMT;
cost_88=cost_8*ADDC_ADT_AMT;
cost_tx=cost_1_txt*ADDC_ADT_AMT;
cost_txother=(cost_1-cost_1_txt)*ADDC_ADT_AMT;
run;</code></pre>
<p><code>-</code> 10대 분류 카테고리 별 비용을 산출하기 위한 과정</p>
<p><br></p>
<pre><code>proc sql;
create table aaa.pre_index_cost3 as
select *, sum(addc_adt_amt) as t30_amt_mid, max(cost_1) as med_mid, max(cost_2) as admmed_mid, max(cost_3) as jin_mid,  max(cost_4) as gumsa_mid,
max(cost_5) as hos_mid, max(cost_6) as sur_mid, max(cost_7) as image_mid
from aaa.pre_index_cost2
group by MID;
quit;

proc sort data=aaa.pre_index_cost3;
by jid recu_fr_dt;
run;</code></pre>
<p><code>-</code> 명세서 단위의 총액 및 10대 분류 여부 코딩 (예: 특정 명세서에 약품 처방내역이 있을 경우 med_mid=1로 코딩됨)</p>
<p><br></p>
<pre><code>proc sql;
create table aaa.pre_index_cost4 as
select distinct *, sum(cost_11) as cost_med, sum(cost_22) as cost_admmed, sum(cost_33) as cost_jin, sum(cost_44) as cost_gumsa, 
sum(cost_55) as cost_hos, sum(cost_66) as cost_sur, sum(cost_77) as cost_image, sum(cost_88) as cost_other, sum(cost_tx) as cost_tx_med, sum(cost_txother) as cost_other_med,
sum(cost_1) as num_med, sum(cost_2) as num_admmed, sum(cost_3) as num_jin, sum(cost_4) as num_gumsa, sum(cost_5) as num_hos, sum(cost_6) as num_sur, sum(cost_7) as num_image, sum(cost_1_txt) as num_tx
from aaa.pre_index_cost3
group by JID;
quit;</code></pre>
<p><code>-</code> 환자 단위로 카테고리 별 비용 및 총 수행횟수 합산</p>
<p><br></p>
<pre><code>data aaa.pre_index_cost5;
set aaa.pre_index_cost4;
fw_month=dur1/30.42;
run;

/*
if rvd_rpe_tamt_amt=&#39;.&#39; then rvd_rpe_tamt_amt=&#39;0&#39;;
if rvd_p100lt_tot_amt=&#39;.&#39; then rvd_p100lt_tot_amt=&#39;0&#39;;
sg_amt_mid=rvd_rpe_tamt_amt+rvd_p100lt_tot_amt;
*/

proc sort data=aaa.pre_index_cost5 out=aaa.pre_index_cost6 nodupkey;
by jid recu_fr_dt mid;
run;</code></pre>
<p><code>-</code> 환자 별로 follow up 기간이 다를 것을 고려하여, 월 단위의 fw 기간으로 전환 (dur1=환자의 f/u 기간(days))</p>
<ul>
<li>총액에 대해 심결요양비용으로 보고싶을 경우는 좌측 코딩을 활용할 수 있음.
다만 sg_amt_mid와 30table로 쪼개진 addc_adt_amt의 합이 맞지 않아서 10대 분류로 쪼개서 볼 경우 addc_adt_Amt로만 산출하였음.</li>
</ul>
<p><code>-</code> 명세서 단위로 산출되었으므로 중복제거</p>
<p><br></p>
<pre><code>data aaa.pre_index_cost7;
set aaa.pre_index_cost6;
keep JID  mid death t30_amt_mid  med_mid admmed_mid jin_mid gumsa_mid hos_mid sur_mid image_mid fw_cost  cost_med cost_admmed cost_jin cost_gumsa cost_hos cost_sur cost_image cost_emer cost_tx_med cost_other_med num_med num_admmed num_jin num_gumsa num_hos num_sur num_image cost_other num_tx fw_month max_amt_mid post fw_month_post fw_month_pre;
run;
/*MID=509,353*/


proc sql;
create table aaa.pre_index_cost7_1 as
select distinct *, count(mid) as tot_visit, sum(t30_amt_mid) as tot_amt_jid_t30, sum(med_mid) as num2_med, sum(admmed_mid) as num2_admmed, sum(jin_mid) as num2_jin,
sum(gumsa_mid) as num2_gumsa, sum(hos_mid) as num2_hos, sum(sur_mid) as num2_sur, sum(image_mid) as num2_image
from aaa.pre_index_cost7
group by JID;
quit;

proc sort data=aaa.pre_index_cost7_1 out=aaa.pre_index_cost8 nodupkey;
by JID;
run;</code></pre>
<p><code>-</code> 환자 단위로 특정기간 동안 발생한 모든 방문, 비용 총액 (tot_amt_jid_t30), 카테고리별 발생되었던 명세서 수 산출</p>
<p><br></p>
<pre><code>data aaa.pre_index_cost8;
set aaa.pre_index_cost8;
aver_totamt=tot_amt_jid_t30/fw_month;
aver_visit=tot_visit/fw_month;
aver_med=cost_med/fw_month;
aver_tx_med=cost_tx_med/fw_month;
aver_other_med=cost_other_med/fw_month;
aver_admmed=cost_admmed/fw_month;
aver_jin=cost_jin/fw_month;
aver_gumsa=cost_gumsa/fw_month;
aver_hos=cost_hos/fw_month;
aver_sur=cost_sur/fw_month;
aver_image=cost_image/fw_month;
aver_other=cost_other/fw_month;
run;</code></pre>
<p><code>-</code> 환자당 평균 월별 비용을 산출하기 위해 산출된 총액을 환자별 f/u 기간(월로 산출)으로 나눈 변수 생성</p>
<p><br></p>
<pre><code>proc means data=aaa.pre_index_cost8 mean std median max;
var tot_amt_jid_t30 fw_month aver_totamt aver_visit ;
run;</code></pre>
<p><code>-</code> 해당 연구기간에서는 총 1년간 의료비용을 정리하였으므로 포함된 환자의 다음 정보의 평균 산출<br />
- 연간 의료비 (tot_amt_jid_t30)<br />
- 추적 관찰 기간(fw_month)<br />
- 월평균 의료비 (aver_totamt)<br />
- 평균 의료기관 방문 횟수(aver_visit)</p>
<p><br></p>
<ul>
<li>hospitalization</li>
</ul>
<pre><code>data aaa.pre_hos;
set aaa.pre_index_cost5;
if fom_tp_cd=&#39;021&#39;;
run;</code></pre>
<p><code>-</code> 명세서 단위로 정리된 pre_index_cost5 중 외과입원에 대한 명세서(021)만 남김</p>
<p><br></p>
<ul>
<li>episode 정의</li>
</ul>
<p><code>-</code> 입원의 경우 월별 정산 등의 사유로 1번의 episode에 해당하는 입원임에도 불구하고 분할 청구 될 수 있음. 이럴 경우 입원횟수의 과대추정 및 평균 입원 기간이 과소 추정 될 수 있으므로 계산 필요<br />
(아래 예시 참고)</p>
<table>
<thead>
<tr class="header">
<th align="center">JJD</th>
<th align="center">recu_fr_dd</th>
<th align="center">recu_to_dd</th>
<th align="center">lag_hos_off</th>
<th align="center">gap_epi</th>
<th align="center">입원 기간</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">2012-01-01</td>
<td align="center">2012-01-14</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">14</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">2012-01-15</td>
<td align="center">2012-01-20</td>
<td align="center">2012-01-14</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">2012-01-31</td>
<td align="center">2012-02-13</td>
<td align="center">2012-01-20</td>
<td align="center">11</td>
<td align="center">14</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center">↓</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr class="odd">
<td align="center">JJD</td>
<td align="center">recu_fr_dd</td>
<td align="center">recu_to_dd</td>
<td align="center">lag_hos_off</td>
<td align="center">gap_epi</td>
<td align="center"></td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">2012-01-01</td>
<td align="center">2012-01-20</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">20</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">2012-01-31</td>
<td align="center">2012-02-13</td>
<td align="center">2012-01-20</td>
<td align="center">11</td>
<td align="center">14</td>
</tr>
</tbody>
</table>
<p><br></p>
<pre><code>proc sort data=aaa.pre_hos out=cost_hos_epi nodupkey;
by JID recu_fr_dt MID; 
run;

data cost_hos_epi;
set cost_hos_epi;
format recu_to_dt yymmdd10.;
recu_to_dt=recu_fr_dt+vst_ddcnt-1;
run;

proc sort data=cost_hos_epi;
by JID recu_fr_dt;
run;</code></pre>
<p><code>-</code> 요양개시일자(입원일자)로부터 퇴원일자를 산출</p>
<p><br></p>
<pre><code>data cost_hos_epi1;
set cost_hos_epi;
by JID;
lag_hos_off=lag(recu_to_dt);
if first.JID then lag_hos_off=&#39;.&#39;;
gap_epi=recu_fr_dt-lag_hos_off;
run;

data cost_hos_epi2;
set cost_hos_epi1;
format lag_hos_off yymmdd10.;
keep jid mid vst_ddcnt recu_fr_dt recu_to_dt gap_epi lag_hos_off;run;
data cost_hos_epi3;
set cost_hos_epi2;
format lag_recufr yymmdd10.;
lag_recufr=lag(recu_fr_dt);

if gap_epi&lt;=1 then flag=0;
else if gap_epi&gt;=2 then flag=1;
if lag_hos_off=&#39;.&#39; then flag=&#39;.&#39;;
run;

proc sort data=cost_hos_epi3;
by JID recu_fr_dt;
run;</code></pre>
<p><code>-</code> 환자 단위로 입원 일자를 한줄 씩 내린 후, 다음 입원 시작일자와의 차이를 산출함
(상기 그림 예시 참고)<br />
<code>-</code> gap_epi가 1일 경우, flag=0으로 코딩</p>
<p><br></p>
<pre><code>data cost_hos_epi4;
set cost_hos_epi3;
by JID;
retain hos_num 0;
if first.JID then hos_num=1;
else hos_num+flag;
drop lag_hos_off;
run;</code></pre>
<p><code>-</code> hos_num이라는 입원횟수에 대한 변수 생성하여, 새로 counting</p>
<p><br></p>
<pre><code>proc sql;
create table cost_hos_epi5 as
select *, sum(vst_ddcnt) as hos_dur
from cost_hos_epi4 
group by JID, hos_num;
quit;</code></pre>
<p><code>-</code> hos_num에 따른 입원 기간(hos_dur) 산출</p>
<p><br></p>
<ul>
<li>episode 정보 붙이기</li>
</ul>
<pre><code>proc sql;
create table aaa.pre_hos1 as
select distinct a.*, b.hos_num, b.hos_dur
from aaa.pre_hos as a left join cost_hos_epi5 as b
on a.MID=b.MID;
quit;</code></pre>
<p><code>-</code> 입원 관련 명세서 정보가 담긴 data에 hos_num 및 hos_dur 정보 연결</p>
<p><br></p>
<pre><code>data aaa.pre_hos1_1;
set aaa.pre_hos1;
drop t30_amt_mid--sg_amt_mid;
run;

proc sort data=aaa.pre_hos1_1;
by jid recu_fr_Dt hos_num;
run;</code></pre>
<p><code>-</code> 불필요한 변수를 제거하는 과정이므로 해당 코드는 불필요할 수 있음</p>
<p><br></p>
<pre><code>proc sql;
create table aaa.pre_hos1_2 as
select *, max(cost_1) as med_mid, max(cost_2) as admmed_mid, max(cost_3) as jin_mid,  max(cost_4) as gumsa_mid,
max(cost_5) as hos_mid, max(cost_6) as sur_mid, max(cost_7) as image_mid
from aaa.pre_hos1_1
group by jid, hos_num;
quit;


proc sort data=aaa.pre_hos1_2;
by jid recu_fr_dt;
run;</code></pre>
<p><code>-</code> 환자별 입원 당, 카테고리별 비용발생 여부</p>
<p><br></p>
<pre><code>proc sql;
create table aaa.pre_hos2 as
select *, sum(addc_adt_amt) as t30_amt, sum(cost_11) as cost_med_hos, sum(cost_22) as cost_admmed_hos, sum(cost_33) as cost_jin_hos,
sum(cost_44) as cost_gumsa_hos, sum(cost_55) as cost_hos_hos, sum(cost_66) as cost_sur_hos, sum(cost_77) as cost_image_hos,
sum(cost_88) as cost_other_hos, sum(cost_tx) as cost_tx_med_hos, sum(cost_txother) as cost_other_med_hos,
from aaa.pre_hos1_2
group by JID; quit; 

proc sort data=aaa.pre_hos2 out=aaa.pre_hos3 nodupkey;
by jid recu_fr_dt mid;
run;</code></pre>
<p>환자 당 발생한<br />
<code>-</code> 입원비 총액(t30_amt)<br />
<code>-</code> 입원 중 약품비(cost_med_hos)이 때, 치료제로 인한 약품비, 그 외 약품비용도 별고 산출 (cost_tx_med_hos, cost_other_med_hos)<br />
<code>-</code> 입원 중 약품 투약비(cost_admmed_hos)<br />
<code>-</code> 입원 중 진찰료 (cost_jin_hos)<br />
<code>-</code> 입원 중 검사료 (cost_gumsa)hos)<br />
<code>-</code> 입원 비용(cost_hos_hos)<br />
<code>-</code> 입원 중 수술료 (cost_sur_hos)<br />
<code>-</code> 입원 중 영상 진단 및 방사선 (cost_image_hos)<br />
<code>-</code> 기타 입원 관련 비용 (cost_other)</p>
<p><br></p>
<pre><code>proc sql; 
create table aaa.pre_hos4 as
select distinct *, max(hos_num) as hos_num_jid
from aaa.pre_hos3
group by JID;
quit;

proc sort data=aaa.pre_hos4 out=aaa.pre_hos5 nodupkey;
by JID;
run;</code></pre>
<p><code>-</code> 환자 당 1년 간 총 입원기간(hos_dur2), 총 입원횟수(hos_num_jid) 생성</p>
<p><br></p>
<pre><code>data aaa.pre_hos6;
set aaa.pre_hos5;
freq_hos=hos_num_jid/fw_month;
aver_hos=t30_amt/fw_month;
aver_hos_epi=t30_amt/hos_num_jid;
aver_hos_med=cost_med_hos/fw_month;
aver_hos_admmed=cost_admmed_hos/fw_month;
aver_hos_jin=cost_jin_hos/fw_month;
aver_hos_gumsa= cost_gumsa_hos/fw_month;
aver_hos_hos=cost_hos_hos/fw_month;
aver_hos_sur=cost_sur_hos/fw_month; 
aver_hos_image=cost_image_hos/fw_month;
aver_hos_other=cost_other_hos/fw_month;
aver_hos_tx=cost_tx_med_hos/fw_month;
aver_hos_txother=cost_other_med_hos/fw_month;
aver_hos_jin2=cost_jin_hos/hos_num_jid;
run;

proc means data=aaa.pre_hos6;
var freq_hos hos_dur_epi aver_hos_jin2;
run; </code></pre>
<p><code>-</code> 월별 평균 방문횟수, 입원 비용, episode 당 입원 비용 등 산출</p>
<p><br></p>
<ul>
<li>외래</li>
</ul>
<pre><code>data aaa.pre_out;
set aaa.pre_index_cost5;
if fom_tp_cd=&#39;031&#39;;
run;


proc sql;
create table aaa.pre_out2 as
select *, sum(cost_11) as cost_med_out, sum(cost_22) as cost_admmed_out, sum(cost_33) as cost_jin_out,
sum(cost_44) as cost_gumsa_out, sum(cost_55) as cost_hos_out, sum(cost_66) as cost_sur_out, sum(cost_77) as cost_image_out,
sum(cost_88) as cost_other_out, sum(cost_tx) as cost_tx_med_out, sum(cost_txother) as cost_other_med_out,
sum(cost_1) as num_med_out, sum(cost_2) as num_admmed_out, sum(cost_3) as num_jin_out,
sum(cost_4) as num_gumsa_out, sum(cost_5) as num_hos_out, sum(cost_6) as num_sur_out, sum(cost_7) as num_image_out,
sum(cost_1_txt) as num_tx_out
from aaa.pre_out
group by JID;
quit; 

proc sort data=aaa.pre_out2 out=aaa.pre_out3 nodupkey;
by jid recu_fr_dt mid ;
run;</code></pre>
<p><br></p>
<pre><code>data aaa.pre_out3;
set aaa.pre_out3;
max_amt_mid=max(sg_amt_mid, t30_amt_mid);
keep JID mid insup_tp_cd  death new_death group_meno t30_amt_mid
med_mid admmed_mid jin_mid  gumsa_mid hos_mid sur_mid image_mid 
cost_med_out cost_admmed_out cost_jin_out cost_gumsa_out cost_hos_out cost_sur_out
cost_image_out cost_other_out cost_tx_med_out cost_other_med_out 
num_med_out num_admmed_out num_jin_out  num_gumsa_out num_hos_out num_sur_out num_image_out num_tx_out 
fw_month max_amt_mid ;
run;</code></pre>
<p><br></p>
<pre><code>proc sql;
create table aaa.pre_out4 as
select *, count(mid) as out_num, sum(t30_amt_mid) as out_amt_t30, sum(max_amt_mid) as out_amt, sum(med_mid) as num2_med_out, sum(admmed_mid) as num2_admmed_out, sum(jin_mid) as num2_jin_out,
sum(gumsa_mid) as num2_gumsa_out, sum(hos_mid) as num2_hos_out, sum(sur_mid) as num2_sur_out, sum(image_mid) as num2_image_out
from aaa.pre_out3
group by JID;
quit;</code></pre>
<p><code>-</code> num_000_out은 환자 당 데이터 기간 내에 발생한 모든 행위 갯수<br />
<code>-</code> num2_000_out은 환자 당 데이터 기간 내에 발생한 이벤트 횟수</p>
<p>예: 환자가 데이터 기간 내에 적혈구, 백혈구 검사(각 행위항목)를 1번 했다면,<br />
<code>-</code> num_gumsa_out=2로 코딩: 환자에게 수행된 모든 검사행위(적혈구, 백혈구 수치 검사))의 갯수<br />
<code>-</code> num2_gumsa_out=1로 코딩: 명세서 당 검사행위가 있었는지(gumsa_mid)의 합이므로, 특정 기간동안 수행된 검사(항목코드 기준 검사료로 청구된 경우) 횟수가 코딩됨</p>
<p><br></p>
<pre><code>proc sort data=aaa.pre_out4  out=aaa.pre_out5 nodupkey;
by JID;
run;

data aaa.pre_out6;
set aaa.pre_out5;
pre_out=1;
freq_out=out_num/fw_month;
freq_out_med=num_med_out/fw_month;
freq_out_admmed=num_admmed_out/fw_month;
freq_out_jin=num_jin_out/fw_month;
freq_out_gumsa=num_gumsa_out/fw_month;
freq_out_hos=num_hos_out/fw_month;
freq_out_sur=num_sur_out/fw_month;
freq_out_image=num_image_out/fw_month;

freq2_out_med=num2_med_out/fw_month;
freq2_out_admmed=num2_admmed_out/fw_month;
freq2_out_jin=num2_jin_out/fw_month;
freq2_out_gumsa=num2_gumsa_out/fw_month;
freq2_out_hos=num2_hos_out/fw_month;
freq2_out_sur=num2_sur_out/fw_month;
freq2_out_image=num2_image_out/fw_month;


aver_out=out_amt_t30/fw_month;
aver_out_med=cost_med_out/fw_month;
aver_out_tx=cost_tx_med_out/fw_month;
aver_out_txother=cost_other_med_out/fw_month;
aver_out_admmed=cost_admmed_out/fw_month;
aver_out_jin=cost_jin_out/fw_month;
aver_out_gumsa= cost_gumsa_out/fw_month;
aver_out_hos=cost_hos_out/fw_month;
aver_out_sur=cost_sur_out/fw_month; 
aver_out_image=cost_image_out/fw_month;
aver_out_other=cost_other_out/fw_month;
run;</code></pre>
<p><br></p>
<pre><code>proc sql;
create table aaa.pre_cost_final as
select distinct a.JId, a.aver_totamt, a.aver_visit,  a.death, a.tot_amt_jid_t30, a.fw_month,a.aver_med,a.aver_tx_med, a.aver_other_med, a.aver_admmed,
a.aver_jin, a.aver_gumsa, a.aver_hos, a.aver_sur, a.aver_image, a.aver_other,

b.freq_hos, b.hos_dur_epi, b.aver_hos as aver_hos_amt, b.aver_hos_epi, b.aver_hos_med, b.aver_hos_tx, b.aver_hos_txother, b.aver_hos_admmed, b.aver_hos_jin, 
b.aver_hos_gumsa, b.aver_hos_hos, b.aver_hos_sur, b.aver_hos_image, b.aver_hos_other,  b.pre_hos, b.hos_num_jid,
c.aver_out, c.aver_out_med, c.aver_out_tx, c.aver_out_txother, c.aver_out_admmed, c.aver_out_jin, c.aver_out_gumsa, c.aver_out_sur, c.aver_out_image, c.aver_out_other, c.pre_out,
c.freq_out, c.freq2_out_med, c.freq2_out_admmed, c.freq2_out_jin, c.freq2_out_gumsa, c.freq2_out_sur, c.freq2_out_image,

from aaa.pre_index_cost8 as a 
left join aaa.pre_hos6 as b on a.JID=b.JID
left join aaa.pre_out6 as c on a.JID=c.JID
quit;</code></pre>
<p><code>-</code> pre_hos6, pre_out6의 데이터를 계산할 경우, 외래 혹은 입원이 발생한 환자의 비용이 계산되므로 포함된 모든 환자 정보에 입/내원 비용 정보를 붙임<br />
(예: 총 100명이 포함되었고, 50명만 입원한 경우 pre_hos6은 50명의 입원한 경우에 대한 입원 평균비가 산출.<br />
하지만, 일반적으로 필요한 것은 100명의 특정 기간 동안 발생할 입원비용에 대한 기댓값임)</p>
<p><br></p>
<pre><code>data aaa.pre_cost_final1;
set aaa.pre_cost_final;
if hos_num_jid=&#39;.&#39; then hos_num_jid=0;
if pre_hos=&#39;.&#39; then pre_hos=0;
if pre_out=&#39;.&#39; then pre_out=0;
if freq_out=&#39;.&#39; then freq_out=0;
if freq_hos=&#39;.&#39; then freq_hos=0;
if aver_hos_amt=&#39;.&#39; then aver_hos_amt=0;
if aver_hos_epi=&#39;.&#39; then aver_hos_epi=0;
if hos_dur_epi=&#39;.&#39; then hos_dur_epi=0;

if aver_hos_med=&#39;.&#39; then aver_hos_med=0;
if aver_hos_tx=&#39;.&#39; then aver_hos_tx=0;
if aver_hos_txother=&#39;.&#39; then aver_hos_txother=0;
if aver_hos_admmed=&#39;.&#39; then aver_hos_admmed=0;
if aver_hos_jin=&#39;.&#39; then aver_hos_jin=0;
if aver_hos_gumsa=&#39;.&#39; then aver_hos_gumsa=0;
if aver_hos_hos=&#39;.&#39; then aver_hos_hos=0;
if aver_hos_sur=&#39;.&#39; then aver_hos_sur=0;
if aver_hos_image=&#39;.&#39; then aver_hos_image=0;
if aver_hos_other=&#39;.&#39; then aver_hos_other=0;
if aver_out=&#39;.&#39; then  aver_out=0;
if aver_out_med=&#39;.&#39; then aver_out_med=0;
if aver_out_tx=&#39;.&#39; then aver_out_tx=0;
if aver_out_txother=&#39;.&#39; then aver_out_txother=0;
if aver_out_admmed=&#39;.&#39; then aver_out_admmed=0;
if aver_out_jin=&#39;.&#39; then aver_out_jin=0;
if aver_out_gumsa=&#39;.&#39; then aver_out_gumsa=0;
if aver_out_sur=&#39;.&#39; then aver_out_sur=0;
if aver_out_image=&#39;.&#39; then aver_out_image=0;
if aver_out_other=&#39;.&#39; then aver_out_other=0;

if freq2_out_med=&#39;.&#39; then freq2_out_med=0;
if freq2_out_admmed=&#39;.&#39; then freq2_out_admmed=0;
if freq2_out_jin=&#39;.&#39; then freq2_out_jin=0;
if freq2_out_gumsa=&#39;.&#39; then freq2_out_gumsa=0;
if freq2_out_sur=&#39;.&#39; then freq2_out_sur=0;
if freq2_out_image=&#39;.&#39; then freq2_out_image=0;
run;</code></pre>
<p><code>-</code> 나중에 평균을 내거나 할 때 전체 N을 100(위의 예시)으로 하기 위해 변수들 결측치를 다 0으로 처리</p>
<p><br></p>
<p>□ 질병 특이적인 비용 산출</p>
<pre><code>proc sql;
create table pre_cost_BC as
select distinct a.*, b.sick_cd,c.recu_fr_dd
from aaa.pre_index_cost6 as a left join rawdata.T400_2018Q2_23 as b on a.mid=b.mid
left join rawdata.t200_2018q2_23 as c on a.mid=c.mid;
quit;</code></pre>
<p><code>-</code> 앞 과정에서 명세서 단위로 비용이 정리된 데이터 셋(aaa.pre_index_cost6)에 해당 명세서의 질병코드를 연결</p>
<p><br></p>
<pre><code>data cost_BC;
set pre_cost_BC;
msick=substr(sick_cd,2,3);
*ssick=substr(sub_sick,1,3);
run;</code></pre>
<p><code>-</code> 코드정보를 정리하고, 암 관련 코드가 포함된 경우 ‘bc_record’로 정의</p>
<p><br></p>
<pre><code>data cost_BC1;
set cost_BC;
if (msick in (&#39;C50&#39; &#39;C77&#39; &#39;C78&#39; &#39;c79&#39;) or treatmedi=1) then bc_record=1;
else bc_record=0;
run;
data cost_bc2;
set cost_bc1;
if bc_record=1;
run;

proc sort data=cost_bc2 out=cost_bc3 nodupkey;
by mid;
run;</code></pre>
<p><code>-</code> 해당 변수에 해당하는 경우를 남기고, 명세서 정보를 남김</p>
<p><br></p>
<pre><code>proc sql;
create table bc.pre_cost_BC as
select *
from aaa.pre_index_cost5
where MID in (select MID from cost_bc3);
quit;

proc sort data= bc.pre_cost_BC;
by jid recu_fr_dt;
run;

data bc.pre_cost_BC1;
set bc.pre_cost_BC;
keep JID mid fom_tp_cd recu_fr_Dt div_cd div_ty_cd death group_meno cz_item_cd amt addc_adt_amt treatmedi vst_ddcnt;
run;</code></pre>
<p><code>-</code> 특정 조건을 만족한 명세서 번호만 재 추출하여 비용분석 코딩 반복</p>
<p><br></p>
<ul>
<li>응급</li>
</ul>
<pre><code>proc sql;
create table cc.emer as
select distinct a.*, b.ipat_Ariv_pth_tp, b.insup_tp_cd
from aaa.data2 as a left join rawdata.t200_2018q2_23 as b
on a.mid=b.mid;
quit;
 
data cc.cost_emer;
set cc.emer;
if recu_fr_Dt&gt;=second_date;
inpat_pt=substr(ipat_Ariv_pth_tp,2,1);
if (div_cd in (&#39;AC101&#39; &#39;AC103&#39; &#39;AC105&#39;)) or dsbjt_cd=&#39;24&#39; or inpat_pt=&#39;1&#39; then emer=1;
else emer=0;
if (div_cd in (&#39;AC101&#39; &#39;AC103&#39; &#39;AC105&#39;)) or dsbjt_cd=&#39;24&#39;  then emer2=1;
else emer2=0; run;</code></pre>
<p><code>-</code> 응급실 정의에서 응급 방문을 통한 입원을 포함한 정의는 emer, 제외한 정의는 emer2</p>
<p><br></p>
<pre><code>proc sql;
create table emer_list as
select distinct JID, MID, max(emer) as emer,max(emer2) as emer2
from cc.cost_emer
group by MID; quit;

data emer_list1;
set emer_list;
if emer=1; run;

proc sql;
create table cc.cost_emer2 as
select *
from cc.cost_emer 
where MID in (select MID from emer_list1); quit;

proc sql;
select count( distinct MID)
from cc.cost_Emer2; quit;


proc sql;
create table cc.cost_emer3 as
select JID, insup_tp_cd, mid, recu_fr_dt,  fom_tp_cd, pat_Age, vst_ddcnt, div_cd, cz_item_cd, div_Ty_cd, 
sum(addc_adt_amt) as t30_amt_mid, max(emer) as emer,max(emer2) as emer2
from cc.cost_emer2
group by MID;
quit;
*혹여 행위 보고싶으면 위 db;

proc sort data=cc.cost_emer3 out=cc.cost_emer4 nodupkey;
by JID mid;
run;

proc sql;
create table cc.cost_emer5 as
select distinct a.*, b.fw_month, b.group_meno
from cc.cost_emer4 as a left join aaa.all_post_cost_final1 as b
on a.JID=b.JID;
quit;

data cc.cost_emer5_1;
set cc.cost_emer5;
amt_emer1=t30_amt_mid*emer;
amt_emer2=t30_amt_mid*emer2;
run;


proc sql;
create table  cc.cost_emer6 as
select distinct *, sum(amt_emer1) as amt_emer_jid, sum(amt_emer2) as amt_emer2_jid, sum(emer) as emer_num,sum(emer2) as emer2_num
from  cc.cost_emer5_1 
group by JID;
quit;

proc sort data=cc.cost_emer6 out=cc.cost_emer7 nodupkey;
by JID;
run;
data cc.cost_emer8;
set cc.cost_emer7;
aver_emer=amt_emer_jid/fw_month;
freq_emer=emer_num/fw_month;
aver_emer2=amt_emer2_jid/fw_month;
freq_emer2=emer2_num/fw_month; run;

proc means data=cc.cost_emer8 mean std median max;
var aver_emer freq_emer aver_emer2 freq_emer2; run;

proc means data=cc.cost_emer8 mean std median max;
var aver_emer freq_emer aver_emer2 freq_emer2;
class group_meno; run;</code></pre>
<p><br></p>
<ul>
<li>결과: 해당 연구결과는 특정 시점 전, 후 비교를 수행하였기에 아래와 같이 표시함</li>
</ul>
<table style="width:100%;">
<colgroup>
<col width="27%" />
<col width="11%" />
<col width="6%" />
<col width="9%" />
<col width="6%" />
<col width="16%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"></th>
<th align="center">1 year prior to regression</th>
<th align="center"></th>
<th align="center">1 year after progression</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">All-cause cost in overall population <br> (n=2,480)¶</td>
<td align="center">Value‡</td>
<td align="center">%</td>
<td align="center">Value‡</td>
<td align="center">%</td>
<td align="center">Changes¶ <br> (ref. 1 year prior to)</td>
<td align="center">P-value</td>
<td align="center">Ratio of value</td>
<td align="center">Ratio of proportion</td>
</tr>
<tr class="even">
<td align="left">Total cost during 1year</td>
<td align="center">11,393,837</td>
<td align="center">-</td>
<td align="center">24,922,558</td>
<td align="center">-</td>
<td align="center">13,528,721</td>
<td align="center">&lt;0.0001</td>
<td align="center">2.2</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">Average follow up duration (months)</td>
<td align="center">11.4</td>
<td align="center">-</td>
<td align="center">9.9</td>
<td align="center">-</td>
<td align="center">-1.5</td>
<td align="center">&lt;0.0001</td>
<td align="center">0.9</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">Resource Utilization during 1 year <br> - Hospitalization rate (%)§ <br> - Number of hospitalization (number)† <br> - Average hospitalization days† <br> - Rate of outpatient visit (%)§</td>
<td align="center"><br> 62.9% <br> 2.8 <br> 6.0 <br> 100%</td>
<td align="center"><br> - <br> - <br> - <br> -</td>
<td align="center"><br> 78.7% <br> 4.9 <br> 10.0 <br> 98%</td>
<td align="center"><br> - <br> - <br> - <br> -</td>
<td align="center"><br> 15.8% <br> 2.1 <br> 4.0 <br> -1.9%</td>
<td align="center"><br> <br> <br> &lt;0.0001 <br></td>
<td align="center"><br> 1.3 <br> 1.8 <br> 1.7 <br> 1.0</td>
<td align="center"><br> - <br> - <br> - <br> -</td>
</tr>
<tr class="odd">
<td align="left">Average medical cost(PPPM)</td>
<td align="center">1,004,096</td>
<td align="center">100.0%</td>
<td align="center">4,710,119</td>
<td align="center">100.0%</td>
<td align="center">3,707,476</td>
<td align="center">&lt;0.0001</td>
<td align="center">4.7</td>
<td align="center"></td>
</tr>
<tr class="even">
<td align="left">Inpatient subtotal <br> - Doctor’s fee <br> - Medication <br> <code>-</code> For anticancer drug <br> <code>-</code> Except anticancer <br> - Administration or injection for drug <br> - Lab test <br> - Image <br> - Hospitalization fee <br> - Surgery <br> - Other</td>
<td align="center">445,736 <br> 1,906 <br> 115,457 <br> 62,868 <br> 52,589 <br> 17,250 <br> 51,008 <br> 83,126 <br> 98,670 <br> 59,960 <br> 18,360</td>
<td align="center">44.4% <br> 0.2% <br> 11.5% <br> 6.3% <br> 5.2% <br> 1.7% <br> 5.1% <br> 8.3% <br> 9.8% <br> 6.0% <br> 1.8%</td>
<td align="center">3,225,596 <br> 6,564 <br> 731,593 <br> 291,815 <br> 439,778 <br> 413,090 <br> 483,381 <br> 425,461 <br> 680,104 <br> 351,595 <br> 133,808</td>
<td align="center">68.5% <br> 0.1% <br> 15.5% <br> 6.2% <br> 9.3% <br> 8.8% <br> 10.3% <br> 9.0% <br> 14.4% <br> 7.5% <br> 2.8%</td>
<td align="center">2,781,161 <br> 4,661 <br> 616,431 <br> 229,065 <br> 387,367 <br> 396,007 <br> 432,568 <br> 342,506 <br> 581,708 <br> 291,777 <br> 115,503</td>
<td align="center">&lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> 0.0014 <br> &lt;0.0001 <br> 0.001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001</td>
<td align="center">7.2 <br> 3.4 <br> 6.3 <br> 4.6 <br> 8.4 <br> 23.9 <br> 9.5 <br> 5.1 <br> 6.9 <br> 5.9 <br> 7.3</td>
<td align="center">1.5 <br> 0.7 <br> 1.4 <br> 1.0 <br> 1.8 <br> 5.1 <br> 2.0 <br> 1.1 <br> 1.5 <br> 1.3 <br> 1.6</td>
</tr>
<tr class="odd">
<td align="left">Outpatient subtotal <br> - Doctor’s fee <br> - Medication <br> <code>-</code> For anticancer drug <br> <code>-</code> Except anticancer <br> - Administration or injection for drug <br> - Lab test <br> - Image <br> - Other</td>
<td align="center">558,360 <br> 36,169 <br> 211,826 <br> 111,052 <br> 100,774 <br> 6,145 <br> 57,640 <br> 229,976 <br> 16,600</td>
<td align="center">55.6% <br> 3.6% <br> 21.1% <br> 11.1% <br> 10.0% <br> 0.6% <br> 5.7% <br> 22.9% <br> 1.7%</td>
<td align="center">1,484,523 <br> 41,020 <br> 1,122,810 <br> 982,488 <br> 140,322 <br> 20,113 <br> 72,288 <br> 195,157 <br> 33,047</td>
<td align="center">31.5% <br> 0.9% <br> 23.8% <br> 20.9% <br> 3.0% <br> 0.4% <br> 1.5% <br> 4.1% <br> 0.7%</td>
<td align="center">926,315 <br> 4,858 <br> 911,196 <br> 871,612 <br> 39,584 <br> 13,969 <br> 14,652 <br> -34,896 <br> 16,448</td>
<td align="center">&lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001 <br> &lt;0.0001</td>
<td align="center">2.7 <br> 1.1 <br> 5.3 <br> 8.8 <br> 1.4 <br> 3.3 <br> 1.3 <br> 0.8 <br> 2.0</td>
<td align="center">0.6 <br> 0.2 <br> 1.1 <br> 1.9 <br> 0.3 <br> 0.7 <br> 0.3 <br> 0.2 <br> 0.4</td>
</tr>
</tbody>
</table>
<ul>
<li>응급실 방문 빈도 및 평균 비용(단위: 환자 당 월 평균 비용)</li>
</ul>
<table style="width:100%;">
<colgroup>
<col width="33%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Unit: per patient per month</th>
<th align="center">All-cause</th>
<th align="center"></th>
<th align="center">Breast cancer related</th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="center">Value</td>
<td align="center">SD</td>
<td align="center">Value</td>
<td align="center">SD</td>
</tr>
<tr class="even">
<td align="left">All patients (n=1,584) <br> - 응급실 통한 입원 포함한 정의 <br> <code>-</code> 빈도 <br> <code>-</code> 평균 의료비용 <br> - 응급실 통한 입원 쟁하한 정의 <br> <code>-</code> 빈도 <br> <code>-</code> 평균 의료비용</td>
<td align="center"><br> <br> 1,731,742 <br> 0.4 <br> <br> 831,488 <br> 0.2</td>
<td align="center"><br> <br> 13,534,295 <br> 1.6 <br> <br> 10,539,440 <br> 1.2</td>
<td align="center"><br> <br> 1,794,096 <br> 0.38 <br> <br> 877,435 <br> 0.18</td>
<td align="center"><br> <br> 13,958,141 <br> 1.6 <br> <br> 10,883,325 <br> 1.2</td>
</tr>
</tbody>
</table>
<p>● 참고) 상기 비용 분석에 대해, 질병 진행 전후의 비용비교 분석 수행<br />
<span class="math display">\[ Y = ax1 + bx2 + … + e \]</span></p>
<p>위와 같이 회귀식을 이용하여 x로 인한 y의 값을 추정할 때,<br />
X와 y가 모두 연속형 변수(non-discrete)이면서, 등분산성 및 정규분포 가정을 만족하는 경우 (BLUE를 충족하는 추정치 산출 가능시) 일반 선형 모형 (general linear model)</p>
<table style="width:100%;">
<colgroup>
<col width="14%" />
<col width="11%" />
<col width="16%" />
<col width="11%" />
<col width="16%" />
<col width="11%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"></th>
<th align="center">Population</th>
<th align="center"></th>
<th align="center">Panel</th>
<th align="center"></th>
<th align="center">Mixed</th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">종족변수의 형태</td>
<td align="center">이론</td>
<td align="center">sas code</td>
<td align="center">이론</td>
<td align="center">sas code</td>
<td align="center">이론</td>
<td align="center">sas code</td>
</tr>
<tr class="even">
<td align="left">Non-discrete</td>
<td align="center">OLS</td>
<td align="center">Proc reg</td>
<td align="center">GLS</td>
<td align="center">Proc glm1) with “repeated”</td>
<td align="center">Mixed effect 고려</td>
<td align="center">Proc mixed “random“</td>
</tr>
<tr class="odd">
<td align="left">discrete</td>
<td align="center">GLM2)</td>
<td align="center">Proc genmod</td>
<td align="center">GEE3)</td>
<td align="center">Proc genmod “repeated”</td>
<td align="center">GLMM4)</td>
<td align="center">Proc glimmix “random“</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li>General linear model</li>
<li>Generalized linear model</li>
<li>Generalized estimating equation</li>
<li>Generalized linear mixed model</li>
</ol>
<p><br></p>
<p>이 때, 비용은 연속형 변수이나 데이터 특성상 정규분포 만족이 어려우므로, 일반적으로 비용분석에서 적용하는 gamma 분포 및 log-link function을 적용한 GEE가 적용되어야 함.
<br></p>
<ul>
<li>model1</li>
</ul>
<pre><code>proc genmod data=aaa.glm2;
class JID point(ref=&#39;0&#39;) group_meno(ref=&#39;1&#39;) bone(ref=&#39;0&#39;) brain(ref=&#39;0&#39;)  liver(ref=&#39;0&#39;)  lung(ref=&#39;0&#39;)  lymph(ref=&#39;0&#39;)  others(ref=&#39;0&#39;) cci_group(ref=&#39;1&#39;)
anemia(ref=&#39;0&#39;) depr(ref=&#39;0&#39;)  demen(ref=&#39;0&#39;)  hyper(ref=&#39;0&#39;)  osteo(ref=&#39;0&#39;)  co_pain(ref=&#39;0&#39;) ;

model aver_totamt=bone brain liver lung lymph others cci_group anemia depr demen hyper osteo co_pain group_meno point /dist=gamma link=log type3;
repeated subject=JID/withinsubject=point CORR=unstr corrw;
estimate &quot;group_meno&quot; group_meno 1 -1/exp;
estimate &#39;point&#39; point 1 -1/exp; run;</code></pre>
<p><br></p>
<ul>
<li>model2</li>
</ul>
<pre><code>proc genmod data=aaa.glm2;
class JID point(ref=&#39;0&#39;) new_death(ref=&#39;0&#39;) group_meno(ref=&#39;1&#39;) bone(ref=&#39;0&#39;) brain(ref=&#39;0&#39;)  liver(ref=&#39;0&#39;)  lung(ref=&#39;0&#39;)  lymph(ref=&#39;0&#39;)  others(ref=&#39;0&#39;) cci_group(ref=&#39;1&#39;)
anemia(ref=&#39;0&#39;) depr(ref=&#39;0&#39;)  demen(ref=&#39;0&#39;)  hyper(ref=&#39;0&#39;)  osteo(ref=&#39;0&#39;)  co_pain(ref=&#39;0&#39;) ;
      
model aver_totamt=bone brain liver lung lymph others cci_group anemia depr demen hyper osteo co_pain group_meno new_death point/dist=gamma link=log type3;
repeated subject=JID/withinsubject=point CORR=unstr corrw;

estimate &quot;group_meno&quot; group_meno 1 -1/exp;
estimate &#39;point&#39; point 1 -1/exp;
estimate &quot;new_death&quot; new_death 1 –1/exp; run;</code></pre>
<p><br></p>
<ul>
<li>model3</li>
</ul>
<pre><code>proc genmod data=aaa.glm2;
class JID point(ref=&#39;0&#39;) new_death(ref=&#39;0&#39;) group_meno(ref=&#39;1&#39;) bone(ref=&#39;0&#39;) brain(ref=&#39;0&#39;)  liver(ref=&#39;0&#39;)  lung(ref=&#39;0&#39;)  lymph(ref=&#39;0&#39;)  others(ref=&#39;0&#39;) cci_group(ref=&#39;1&#39;)
anemia(ref=&#39;0&#39;) depr(ref=&#39;0&#39;)  demen(ref=&#39;0&#39;)  hyper(ref=&#39;0&#39;)  osteo(ref=&#39;0&#39;)  co_pain(ref=&#39;0&#39;) ;
      
model aver_totamt=bone brain liver lung lymph others cci_group anemia depr demen hyper osteo co_pain group_meno new_death point point*new_death/dist=gamma link=log type3;
repeated subject=JID/withinsubject=point CORR=unstr corrw;

estimate &quot;group_meno&quot; group_meno 1 -1/exp;
estimate &#39;point&#39; point 1 -1/exp;
estimate &quot;new_death&quot; new_death 1 -1/exp;

estimate &#39;point*new_death&#39; point*new_death 1 -1 -1 1/exp;
estimate &#39;cc&#39; point 1 -1 new_death 1 -1 point*new_death 1 -1 -1 1/exp;

contrast &#39;진행 후 사망에 대한 것&#39; new_death  1 -1, point*new_death 1 -1 -1 1/wald;
contrast &#39;사망한 사람의 전후에 대한 것&#39; point 1 -1, point*new_death 1 -1 –1 1/wald; run;</code></pre>
<ul>
<li>실제 전후 비용의 통계적 유의미성 확인을 위해 paired t-test 수행</li>
</ul>
<pre><code>proc ttest data=aaa.paired_new ;
paired tot_amt_jid_pre*tot_amt_jid_post fw_month_pre*fw_month_post
  aver_totamt_pre*aver_totamt_post; run;</code></pre>
<p><code>-</code> 관심있는 paring 변수에 대해 변수1*변수2로 표현하여 분석</p>
<p><br></p>
<p><img src="fig3/fig3_2.jpg" /></p>
<p><br></p>
</div>
<div id="의료자원-이용-연구" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> 의료자원 이용 연구</h3>
<ul>
<li>연구요약</li>
</ul>
<table>
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">연구목적</th>
<th align="left">신장결석 환자의 의료자원 이용 연구 (의료기관 종별 이용 변동)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">자료원</td>
<td align="left">건강보험심사평가원 전수데이터</td>
</tr>
<tr class="even">
<td align="center">연구 디자인</td>
<td align="left"><img src="fig3/fig3_3.jpg" /></td>
</tr>
<tr class="odd">
<td align="center">대상환자</td>
<td align="left">- 신장결석 (N200) 환자 중 신장결석 혹은 요관 결석 관련 시술을 받은 환자</td>
</tr>
<tr class="even">
<td align="center">포함기준</td>
<td align="left">- 2016년 1월 1일 ~ 2016년 12월 31일 사이 (index period)에 신장결석 혹은 요관 결석 관련 시술을 받은 환자 <br> - 신장결석의 경우, index period 내에 ESWL, PCNL, RIRS 중 하나의 시술을 받았고, 주상병 코드가 ‘N200(신장결석)’인 환자로 한정하였음.</td>
</tr>
<tr class="odd">
<td align="center">제외기준</td>
<td align="left">- index period 내 첫 의무기록 일 (index date) 기준 이전 6개월 간 관련 시술이력이 있는 자는 제외</td>
</tr>
<tr class="even">
<td align="center">정의</td>
<td align="left">- 하나의 에피소드 기간은 index date 기준 이후 6개월(180일)로 정의했음. <br> - 비용 추계를 위한 명세서 수집 기준은 신장결석 환자의 경우, 동일 에피소드 내에 주상병 혹은 제1부상병이 ‘N200’인 경우로 한정하였음 <br> - 최초 시술 이후 재시술 정의 <br> 신장결석 환자로 모집된 환자 즁 동일 에피소드 내에 ESWL, PCNL, RIRS 중 하나의 시술을 받았으며, 주상병 코드가 ‘N200’인 명세서가 발생한 환자</td>
</tr>
</tbody>
</table>
<ul>
<li>분석 Program</li>
</ul>
<p>□ 재시술 환자 정의 후, 환자 당 재시술시 병원 종간 (예: 의원&gt;종합) 이동 확인</p>
<ul>
<li>환자번호 기준으로 20t 갖다붙이기 - 향후 6개월</li>
</ul>
<pre><code>data e.t200_2018q1_26; 
set rawdata.t200_2018q1_26; recu_fr=input(recu_fr_dd,yymmdd8.); run

proc sql;
create table c.index_1
as select a.*, b.* 
from  e.t200_2018q1_26 as a, a.per_1 as b 
where a.jid=b.jid having b.first_dt le a.recu_fr &lt; (b.first_dt+180); quit;

proc sort data=c.index_1; by jid mid; run;

data c.index_1; set c.index_1;
if cl_cd=&#39;31&#39; then yy=1; 
else if cl_cd in (&#39;21&#39;) then yy=2; 
else if cl_cd in (&#39;11&#39;) then yy=3; 
else if cl_cd in (&#39;01&#39;) then yy=4 
else yy=5; run;</code></pre>
<p><code>-</code> input 코드: recu_fr_dd의 변수를 yymmdd8. 형식의 새로운 변수 recu_fr로 바꿈. 형식을 바꾸는 이유는 다른 날짜변수와 상성이 안 맞아 날짜 중심으로 명세서를 발췌해야 하는 proc sql 프로시져가 돌아가지 않는 경우가 있음</p>
<p><code>-</code> 선정된 환자(a.per_1)의 첫 시술일 (first_dt)부터 6개월 이내의 20table 자료를 c.index_1로 생성함</p>
<p><code>-</code> 환자/명세서 단위로 정렬 된 c.index_1 자료원에서 의료기관 종에 대한 코딩<br />
/<em>1=의원; 2=병원; 3=종병; 4=상급종합</em>/</p>
<p><br></p>
<ul>
<li>20t명세서 기준으로 30t 갖다붙이기</li>
</ul>
<pre><code>proc sql create table c.index_2
as select a.*, b.* 
from c.index_1 as a left join b.t300_2018q1_26 as b
on a.mid=b.mid; quit</code></pre>
<p><code>-</code> 환자의 해당 기간 (6개월) 중 원내 명세서 정보를 30table에서 가져옴</p>
<p><br></p>
<ul>
<li>재시술 환자 추출(시술코드만)</li>
</ul>
<pre><code>data c.index_3;
set c.index_2;
suga_re=substr(div_cd,1,5);
if suga_re in (&#39;R3505&#39; &#39;R3506&#39; &#39;R3507&#39;) then trt_re=1;/*eswl*/
else if suga_re in (&#39;R3424&#39; &#39;R3425&#39; &#39;R3426&#39; &#39;R3427&#39;) then trt_re=2; /*rirs*/
else if suga_re in (&#39;R3375&#39;) then trt_re=3; /*pcnl*/
else trt_re=0; run;

data c.index_4; set c.index_3; 
if trt_re in (1 2 3); run

data c.index_4; set c.index_4; 
if main_sick=&#39;N200&#39;; run;</code></pre>
<p><code>-</code> 첫 시술 후 div_cd를 기반으로 (suga_re) 재시술여부(trt_re) 코딩</p>
<p><code>-</code> 선정/배제기준에 따라 신장결석 명세서만 선정함</p>
<p><br></p>
<ul>
<li>index 이후 6개월간 시술횟수</li>
</ul>
<pre><code>proc sort data=c.index_4 out=c.index_5 nodupkey;
by jid recu_fr; run;</code></pre>
<p><code>-</code> 시술횟수 산출을 위하여, 환자(JID)/요양개시일자(recu_fr)를 바탕으로 중복제거하며 정렬</p>
<pre><code>data c.index_6; set c.index_5; by jid;
indi=lag(jid); retain rere;
if first.jid then rere=1;
if indi~=jid then rere=0;
rere+1 run;

@ 참고) 동일 코드
retain rere 0;
if first.jid then rere=1;
else rere+1; run;</code></pre>
<p><code>-</code> 환자별로 명세서 당 한 줄 씩 남은 c.index_6 자료원에서 환자(JID) 기준으로 재시술 횟수(rere)를 산출<br />
→ 이 과정에서 lag(JID)를 indi로 정의하여 JID를 한 줄 씩 미루고, 첫 jid일 경우 시술횟수 1회로 코딩하고, jid와 indi가 같지 않으면 rere를 0으로 코딩</p>
<table>
<thead>
<tr class="header">
<th align="center">JID</th>
<th align="center">recu_fr</th>
<th align="center">indi</th>
<th align="center">rere</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">2010-10-24</td>
<td align="center">.</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">2011-01-09</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">2011-08-18</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">2010-10-24</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">2011-01-09</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">2011-08-18</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">2012-03-26</td>
<td align="center">2</td>
<td align="center">4</td>
</tr>
</tbody>
</table>
<pre><code>data c.index_7; set c.index_6;
if rere=2 then second_dt=recu_fr;
else if rere=3 then third_dt=recu_fr;
else recu_fr=0; run;</code></pre>
<p><code>-</code> rere 횟수에 따라 2번째 시술일 (second_dt)/ 3번째 시술일 (third_dt) 코딩</p>
<p><br></p>
<ul>
<li>병원 이동</li>
</ul>
<pre><code>data c.index_7; set c.index_7;
if rere=1 then first_yy=yy;
else if rere=2 then second_yy=yy;
else if rere=3 then third_yy=yy;
else yy=0run</code></pre>
<p><code>-</code> 시술 별 요양기관 종류 코딩 (의원,병원,종합병원,상급종합,기타)</p>
<p><br></p>
<ul>
<li>재시술횟수</li>
</ul>
<pre><code>proc sort data=c.index_7 out=c.reindex; by jid descending rere; run
proc sort data=c.reindex nodupkey by jid; run


proc freq data=c.reindex; table first_trt*rere; run</code></pre>
<p><code>-</code> 환자 기준으로, rere 역순으로 정렬</p>
<p><code>-</code> c.reindex에서 환자만 남김 (환자 별 총 재시술 횟수를 남기기 위함)</p>
<p><code>-</code> 결과 환자의 첫 시술 (eswl/rirs/pcnl/ursl) 종류에 따른 재시술 횟수</p>
<p><br></p>
<ul>
<li>시술순서</li>
</ul>
<pre><code>proc sort data=c.index_7;by jid rere; run;

proc transpose data=c.index_7 out=c.trt_combi prefix=trt_combi;
by JID; *묶고싶은 변수에 따라 추가 가능;
var trt;
run;</code></pre>
<p>@ 환자 당 재시술번호로 정렬된 데이터를 ‘proc transpose’를 통해 아래와 같은 형태로 변경</p>
<p>(코드: trt라는 변수를 환자(JID) 당 열→행으로 정리해줌, 이 때 trt_combi라는 변수에 열변호가 붙으며 가로로 변환됨)</p>
<table>
<thead>
<tr class="header">
<th align="center">JID</th>
<th align="center">recu_fr</th>
<th align="center">rere</th>
<th align="center">trt</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">2010-10-24</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">2011-01-09</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">2011-08-18</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center">↓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr class="odd">
<td align="center">JID</td>
<td align="center">trt_combi1</td>
<td align="center">trt_combi2</td>
<td align="center">trt_combi3</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<ul>
<li>조합변수생성</li>
</ul>
<pre><code>data c.trt_combi1;
set c.trt_combi;
length trt_combi $10;
trt_combi=catx(&quot;/&quot;, of trt_combi1-trt_combi3);
drop _name_;
run;

proc sort data=c.trt_combi1;
by jid;
run;</code></pre>
<p><code>-</code> trt_combi1~trt_combi3에 대해서 “/”라는 구분자를 통해 trt_combi 변수로 합침<br />
(상기 예시: 1번 환자의 시술조합(trt_combi)은 1/3/1)</p>
<p><code>-</code> 여기서 catx 사용시, 자료원에 따라 transpose된 변수의 개수를 확인하여서 trt_combi**에 붙을 최대숫자를 확인해야함</p>
<p><br></p>
<ul>
<li>성공한 시술 회 차 정의</li>
</ul>
<pre><code>data c.trt_combi2;
set c.trt_combi1;
if length(trt_combi)&gt;5 then rt_4=9; 
else if length(trt_combi)=5 then rt_4=3;
else if length(trt_combi)=3 then rt_4=2;
else rt_4=1; run;
/*rt_4 = 성공한 시술 회차, 9는 시술을 4번 이상 받은 경우*/</code></pre>
<p><code>-</code> 시술의 조합변수 trt_combi의 길이에 따라 시술횟수 정의.</p>
<p><code>-</code> 조합이 3개일 경우 (예:1/3/1), 길이가 5개 이므로 시술이 3회 초과한 경우 실패로 간주하여 9로 코딩</p>
<!------------------------->

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="chapter2.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="chapter4.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Outcome Research.pdf", "Outcome Research.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
